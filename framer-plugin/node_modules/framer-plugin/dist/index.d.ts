import { FC } from 'react';
import { ReactElement } from 'react';
import { RefObject } from 'react';
import ts from 'typescript';

export declare const $framerInternal: {
    readonly getAiServiceInfo: typeof getAiServiceInfoSymbol;
    readonly sendTrackingEvent: typeof sendTrackingEventSymbol;
    readonly environmentInfo: typeof environmentInfoSymbol;
    readonly showUncheckedPermissionToasts: typeof showUncheckedPermissionToastsSymbol;
};

declare interface AddComponentInstanceOptions {
    /** The component module URL. Can be copied from the components panel. */
    url: string;
    /** Optional component attributes. */
    attributes?: Partial<EditableComponentInstanceNodeAttributes>;
}

declare interface AddDetachedComponentLayersOptions {
    /** The component module URL. Can be copied from the components panel. */
    url: string;
    /** Optional component attributes. */
    attributes?: Partial<EditableComponentInstanceNodeAttributes>;
    /** Insert the layers as a layout block and match variants with breakpoints. */
    layout?: boolean;
}

declare interface AddTextOptions {
    tag: TextNodeTag;
}

export declare interface AiServiceInfo {
    endpoint: string;
    token: string;
    expiresAt: string;
}

declare type AllMembers = Omit<FramerPluginAPI, "isAllowedTo" | "subscribeToIsAllowedTo"> & NamespaceMembers<ImageAsset, "ImageAsset"> & NamespaceMembers<CodeFile, "CodeFile"> & NamespaceMembers<CodeFileVersion, "CodeFileVersion"> & NamespaceMembers<ComponentInstancePlaceholder, "ComponentInstancePlaceholder"> & NamespaceMembers<Field, "Field"> & NamespaceMembers<BooleanField, "BooleanField", Field> & NamespaceMembers<ColorField, "ColorField", Field> & NamespaceMembers<NumberField, "NumberField", Field> & NamespaceMembers<StringField, "StringField", Field> & NamespaceMembers<FormattedTextField, "FormattedTextField", Field> & NamespaceMembers<ImageField, "ImageField", Field> & NamespaceMembers<LinkField, "LinkField", Field> & NamespaceMembers<DateField, "DateField", Field> & NamespaceMembers<FieldDivider, "FieldDivider", Field> & NamespaceMembers<UnsupportedField, "UnsupportedField", Field> & NamespaceMembers<FileField, "FileField", Field> & NamespaceMembers<EnumCase, "EnumCase"> & NamespaceMembers<EnumField, "EnumField", Field> & NamespaceMembers<CollectionReferenceField, "CollectionReferenceField", Field> & NamespaceMembers<MultiCollectionReferenceField, "MultiCollectionReferenceField", Field> & NamespaceMembers<ManagedCollection, "ManagedCollection"> & NamespaceMembers<Collection, "Collection"> & NamespaceMembers<CollectionItem, "CollectionItem"> & NamespaceMembers<NodeMethods, "Node"> & NamespaceMembers<FrameNode, "FrameNode", NodeMethods> & NamespaceMembers<TextNode, "TextNode", NodeMethods> & NamespaceMembers<SVGNode, "SVGNode", NodeMethods> & NamespaceMembers<ComponentInstanceNode, "ComponentInstanceNode", NodeMethods> & NamespaceMembers<WebPageNode, "WebPageNode", NodeMethods> & NamespaceMembers<ComponentNode, "ComponentNode", NodeMethods> & NamespaceMembers<UnknownNode, "UnknownNode", NodeMethods> & NamespaceMembers<ColorStyle, "ColorStyle"> & NamespaceMembers<TextStyle, "TextStyle">;

declare const allModesRecord: {
    readonly canvas: true;
    readonly image: true;
    readonly editImage: true;
    readonly configureManagedCollection: true;
    readonly syncManagedCollection: true;
    readonly collection: true;
    readonly localization: true;
    readonly code: true;
};

export declare interface AllTraits<T extends TraitVariant = TraitVariant> extends WithIdTrait, WithNameTrait, WithVisibleTrait, WithLockedTrait, WithBackgroundColorTrait<T>, WithBackgroundImageTrait<T>, WithBackgroundGradientTrait<T>, WithRotationTrait, WithOpacityTrait, WithBorderRadiusTrait, WithComponentInfoTrait, WithControlAttributesTrait, WithSVGTrait, WithPositionTrait, WithPinsTrait, WithSizeTrait, WithSizeConstraintsTrait, WithAspectRatioTrait, WithImageRenderingTrait, WithFontTrait<T>, WithInlineTextStyleTrait<T>, WithWebPageInfoTrait, WithLinkTrait {
}

declare interface AnyEditableAttributes extends EditableFrameNodeAttributes, EditableTextNodeAttributes, EditableSVGNodeAttributes, EditableComponentInstanceNodeAttributes, EditableComponentNodeAttributes, EditableWebPageNodeAttributes {
}

export declare type AnyNode = CanvasNode | CanvasRootNode;

declare interface AnyNodeData extends Partial<AllTraits<TraitVariantData>>, WithReplicaInfoTrait {
    __class: PluginNodeClass;
}

declare interface ApiV2CollectionItemData extends BaseCollectionItemData {
    /** Unique ID. */
    id: string;
    /** Unique slug. */
    slug: string;
    /** Data for the fields. */
    fieldData: ApiV2FieldData;
}

declare type ApiV2CollectionItemInput = ApiV2CreateCollectionItem | ApiV2EditableCollectionItemAttributesWithId;

declare interface ApiV2CreateCollectionItem extends BaseCollectionItemData {
    /** The ID of an existing item if updating. Omit if adding. */
    id?: undefined;
    /** Unique on collection level. Required if adding, optional if updating. */
    slug: string;
    /** Data for the fields. */
    fieldData?: ApiV2FieldData | undefined;
}

declare interface ApiV2EditableCollectionItemAttributes extends BaseCollectionItemData {
    /** Unique on collection level. Required if adding, optional if updating. */
    slug?: string | undefined;
    /** Data for the fields. */
    fieldData?: ApiV2FieldData | undefined;
}

declare interface ApiV2EditableCollectionItemAttributesWithId extends ApiV2EditableCollectionItemAttributes {
    /** The ID of an existing item if updating. Omit if adding. */
    id: NodeId;
}

declare type ApiV2FieldData = Record<string, unknown>;

declare interface ApiV2ManagedCollectionItemInput extends BaseCollectionItemData {
    /** Required unique ID of your choice. Using an ID instead of the slug helps avoid data loss. */
    id: string;
    /** Unique on collection level. */
    slug: string;
    /** Data for the fields. */
    fieldData: ApiV2FieldData;
}

export declare interface ApiVersion1ProjectInfo {
    name: string;
    /** Hashed project id */
    id: string;
}

export declare interface ApiVersion1User {
    name: string;
    /** Hashed user id */
    id: string;
}

declare class ArrayField extends FieldBaseWithRequired {
    readonly type = "array";
    readonly fields: readonly [ArrayItemField];
    constructor(engine: PluginEngine, collectionId: string, data: ArrayFieldDefinitionData);
}

declare interface ArrayFieldBase {
    type: ArrayFieldType;
}

export declare interface ArrayFieldDataEntry {
    type: ArrayFieldType;
    value: ArrayItem[];
}

export declare interface ArrayFieldDataEntryInput {
    type: ArrayFieldType;
    value: ArrayItemInput[];
}

declare interface ArrayFieldDataEntrySerializable {
    type: ArrayFieldType;
    value: ArrayItemSerializableData[];
}

declare interface ArrayFieldDefinitionData extends ArrayFieldBase, WithFieldRequired, FieldDefinitionBase {
    fields: [ArrayItemFieldDefinitionData];
}

declare type ArrayFieldType = typeof arrayFieldType;

declare const arrayFieldType = "array";

export declare interface ArrayItem {
    id: string;
    fieldData: Readonly<ArrayItemFieldData>;
}

export declare interface ArrayItemData {
    /** Unique ID. */
    id: string;
    /** Data for the fields. */
    fieldData: ArrayItemFieldData;
}

declare type ArrayItemField = ImageField;

declare type ArrayItemFieldBase = ImageFieldBase;

declare type ArrayItemFieldData = Record<string, ArrayItemFieldDataEntry>;

declare type ArrayItemFieldDataEntry = ImageFieldDataEntry;

declare type ArrayItemFieldDataEntryInput = ImageFieldDataEntryInput;

declare type ArrayItemFieldDataInput = Record<string, ArrayItemFieldDataEntryInput>;

declare interface ArrayItemFieldDefinitionData extends ArrayItemFieldBase, WithFieldRequired, FieldDefinitionBase {
}

export declare type ArrayItemInput = CreateArrayItem | UpdateArrayItem;

declare interface ArrayItemSerializableData {
    /** Unique ID. */
    id: string;
    /** Data for the fields. */
    fieldData: FieldSerializableData;
}

declare interface AssetData extends WithOptionalName {
    /** Something that can be rendered within the iFrame. Always the original size of the image */
    url: string;
}

declare type AssetDataTransfer = AssetURLDataTransfer | BytesDataTransfer;

declare type AssetId = string;

declare interface AssetIdentifier {
    id: string;
}

declare type AssetInput = string | File | BytesData;

declare type AssetPath = WithAssetName | WithAssetPath;

declare interface AssetURLDataTransfer {
    type: "url";
    url: string;
}

declare interface BaseCollectionItemData {
    /** Drafts are excluded from publishing. */
    draft?: boolean | undefined;
}

export declare class BooleanField extends FieldBase {
    readonly type = "boolean";
}

declare interface BooleanFieldBase {
    type: BooleanFieldType;
}

declare interface BooleanFieldDataEntry {
    type: BooleanFieldType;
    value: boolean;
}

declare type BooleanFieldDataEntryInput = BooleanFieldDataEntry;

declare interface BooleanFieldDefinitionData extends BooleanFieldBase, FieldDefinitionBase {
}

declare type BooleanFieldType = typeof booleanFieldType;

declare const booleanFieldType = "boolean";

export declare type BorderRadius = CSSDimension<CSSUnit.Percentage | CSSUnit.Pixel> | `${CSSDimension<CSSUnit.Pixel>} ${CSSDimension<CSSUnit.Pixel>} ${CSSDimension<CSSUnit.Pixel>} ${CSSDimension<CSSUnit.Pixel>}` | null;

declare interface BytesData {
    bytes: Uint8Array;
    mimeType: string;
}

declare type BytesDataTransfer = BytesData & {
    type: "bytes";
};

export declare type CanvasNode = FrameNode | TextNode | ComponentInstanceNode | SVGNode | VectorSetItemNode | UnknownNode;

export declare type CanvasRootNode = WebPageNode | ComponentNode | VectorSetNode | UnknownNode;

declare type Cleanup = VoidFunction;

declare interface ClosePluginOptions {
    variant?: NotificationVariant;
}

declare interface CodeExportCommon {
    name: string;
    isDefaultExport: boolean;
}

export declare class CodeFile {
    #private;
    get id(): string;
    get name(): string;
    get path(): string;
    get content(): string;
    get exports(): readonly CodeFileExport[];
    get versionId(): string;
    constructor(data: CodeFileData, engine: PluginEngine);
    /**
     * Set the content of this code file.
     *
     * Use `"CodeFile.setFileContent"` to check if this method is allowed.
     */
    setFileContent(code: string): Promise<CodeFile>;
    /**
     * Rename this code file.
     *
     * Use `"CodeFile.rename"` to check if this method is allowed.
     */
    rename(newName: string): Promise<CodeFile>;
    /**
     * Remove this code file.
     *
     * Use `"CodeFile.remove"` to check if this method is allowed.
     */
    remove(): Promise<void>;
    /**
     * Get all versions of this code file.
     */
    getVersions(): Promise<readonly CodeFileVersion[]>;


    lint(rules: LintConfig): Promise<LintDiagnostic[]>;
    typecheck(compilerOptions?: ts.server.protocol.CompilerOptions): Promise<TypecheckDiagnostic[]>;
}

export declare interface CodeFileComponentExport extends CodeExportCommon {
    insertURL: string;
    type: "component";
}

declare interface CodeFileData {
    id: string;
    name: string;
    path: string;
    content: string;
    exports: readonly CodeFileExport[];
    versionId: string;
}

export declare type CodeFileExport = CodeFileComponentExport | CodeFileOverrideExport;

export declare interface CodeFileOverrideExport extends CodeExportCommon {
    type: "override";
}

export declare class CodeFileVersion {
    #private;
    get id(): string;
    get name(): string;
    get createdAt(): string;
    get createdBy(): Readonly<User>;
    constructor(data: CodeFileVersionData, engine: PluginEngine);
    getContent(): Promise<string>;
}

declare interface CodeFileVersionData extends Pick<CodeFileData, "id" | "name"> {
    fileId: string;
    createdAt: string;
    createdBy: User;
}

export declare class Collection {
    #private;
    readonly id: NodeId;
    readonly name: string;
    readonly slugFieldName: string | null;
    readonly slugFieldBasedOn: string | null;
    /**
     * @deprecated Use `managedBy` instead and the [Permissions
     * API](https://www.framer.com/developers/plugins-permissions) to check if users can edit the
     * collection.
     */
    readonly readonly: boolean;
    /**
     * Collections managed by plugins are read-only. To be able to modify them use
     * `ManagedCollection` (which is only possible in `configureManagedCollection` or
     * `syncManagedCollection` modes).
     */
    readonly managedBy: CollectionManagedBy;
    constructor(data: CollectionData, engine: PluginEngine);
    /**
     * Arrange items in a specific order.
     *
     * Use `"Collection.setItemOrder"` to check if this method is allowed.
     */
    setItemOrder(ids: NodeId[]): Promise<void>;
    /**
     * Get all fields.
     */
    getFields(): Promise<Field[]>;
    /**
     * Create new fields. Use `Field.setAttributes` to update.
     *
     * Use `"Collection.addFields"` to check if this method is allowed.
     */
    addFields(fields: CreateField[]): Promise<Field[]>;
    /**
     * Remove fields by their ID.
     *
     * Use `"Collection.removeFields"` to check if this method is allowed.
     */
    removeFields(fieldIds: string[]): Promise<void>;
    /**
     * Arrange fields in a specific order.
     *
     * Use `"Collection.setFieldOrder"` to check if this method is allowed.
     */
    setFieldOrder(fieldIds: string[]): Promise<void>;
    /**
     * Get all items in their set order.
     */
    getItems(): Promise<CollectionItem[]>;
    /**
     * Add new items or update existing ones if their IDs are provided.
     *
     * This creates a new item with "foo" as its slug:
     *
     * ```ts
     * collection.addItems([{ slug: "foo" }])
     * ```
     *
     * This updates an existing item with ID "aBc123" to have "bar" as its slug:
     *
     * ```ts
     * collection.addItems([{ id: "aBc123", slug: "bar" }])
     * ```
     *
     * Use `"Collection.addItems"` to check if this method is allowed.
     */
    addItems(items: CollectionItemInput[]): Promise<void>;
    /**
     * Remove items by their ID.
     *
     * Use `"Collection.removeItems"` to check if this method is allowed.
     */
    removeItems(itemIds: NodeId[]): Promise<void>;
    /**
     * Make this the active collection.
     */
    setAsActive(): Promise<void>;
    /**
     * Set plugin data by key.
     *
     * Use `"Collection.setPluginData"` to check if this method is allowed.
     */
    setPluginData(key: string, value: string | null): Promise<void>;
    /**
     * Get plugin data by key.
     */
    getPluginData(key: string): Promise<string | null>;
    /**
     * Get all plugin data keys.
     */
    getPluginDataKeys(): Promise<string[]>;
}

declare interface CollectionData {
    id: string;
    name: string;
    slugFieldName: string | null;
    slugFieldBasedOn: string | null;
    /** @deprecated Use `managedBy` instead. */
    readonly: boolean;
    managedBy: CollectionManagedBy;
}

export declare class CollectionItem {
    #private;
    readonly id: NodeId;
    readonly slug: string;
    readonly slugByLocale: InlineLocalizationValueByLocale;
    readonly draft: boolean;
    readonly fieldData: Readonly<FieldData>;
    constructor(collectionItemData: CollectionItemSerializableData, engine: PluginEngine);
    /**
     * Remove this item.
     *
     * Use `"CollectionItem.remove"` to check if this method is allowed.
     */
    remove(): Promise<void>;
    /**
     * Update the item.
     *
     * Use `"CollectionItem.setAttributes"` to check if this method is allowed.
     */
    setAttributes(update: EditableCollectionItemAttributes): Promise<CollectionItem | null>;
    /**
     * Set plugin data by key.
     *
     * Use `"CollectionItem.setPluginData"` to check if this method is allowed.
     */
    setPluginData(key: string, value: string | null): Promise<void>;
    /**
     * Get plugin data by key.
     */
    getPluginData(key: string): Promise<string | null>;
    /**
     * Get all plugin data keys.
     */
    getPluginDataKeys(): Promise<string[]>;
}

export declare interface CollectionItemData extends BaseCollectionItemData {
    /** Unique ID. */
    id: string;
    /** Unique slug. */
    slug: string;
    /** Slug by locale. */
    slugByLocale: InlineLocalizationValueByLocale;
    /** Data for the fields. */
    fieldData: FieldData;
}

export declare type CollectionItemInput = CreateCollectionItem | EditableCollectionItemAttributesWithId;

declare interface CollectionItemSerializableData extends BaseCollectionItemData {
    /** Unique ID. */
    id: string;
    /** Unique slug. */
    slug: string;
    /** Slug by locale. */
    slugByLocale: InlineLocalizationValueByLocale;
    /** Data for the fields. */
    fieldData: FieldSerializableData;
}

declare type CollectionManagedBy = "user" | ManagedCollectionManagedBy;

export declare class CollectionReferenceField extends FieldBaseWithRequired implements WithFieldCollectionId {
    #private;
    readonly type = "collectionReference";
    get collectionId(): string;
    constructor(engine: PluginEngine, collectionId: string, data: CollectionReferenceFieldDefinitionData);
}

declare interface CollectionReferenceFieldBase {
    type: CollectionReferenceFieldType;
}

declare interface CollectionReferenceFieldDataEntry {
    type: CollectionReferenceFieldType;
    value: string | undefined;
}

declare interface CollectionReferenceFieldDataEntryInput {
    type: CollectionReferenceFieldType;
    value: string | null;
}

declare interface CollectionReferenceFieldDefinitionData extends CollectionReferenceFieldBase, FieldDefinitionBase, WithFieldCollectionId, WithFieldRequired {
}

declare type CollectionReferenceFieldType = typeof collectionReferenceFieldType;

declare const collectionReferenceFieldType = "collectionReference";

export declare class ColorField extends FieldBase {
    readonly type = "color";
}

declare interface ColorFieldBase {
    type: ColorFieldType;
}

declare interface ColorFieldDataEntry {
    type: ColorFieldType;
    value: string | ColorStyle;
}

declare interface ColorFieldDataEntryInput {
    type: ColorFieldType;
    value: string | ColorStyleData | null;
}

declare interface ColorFieldDataEntrySerializable {
    type: ColorFieldType;
    value: string | ColorStyleData;
}

declare interface ColorFieldDefinitionData extends ColorFieldBase, FieldDefinitionBase {
}

declare type ColorFieldType = typeof colorFieldType;

declare const colorFieldType = "color";

export declare interface ColorStop {
    /** CSS color */
    color: ColorStyle | string;
    /** 0-1 */
    position: number;
}

export declare class ColorStyle {
    #private;
    readonly id: NodeId;
    readonly name: string;
    /**
     * Hierarchical path to the color style in the assets folder structure, e.g. `ui/modals/background`.
     * Used for organizing color styles in the UI and for programmatic access.
     * Segments are separated by forward slashes.
     */
    readonly path: string;
    /** Color used for the default or light theme in RGBA format, e.g `rgba(242, 59, 57, 1)` */
    readonly light: string;
    /** Optional color used for the dark theme in RGBA format, e.g `rgba(242, 59, 57, 1)` */
    readonly dark: string | null;
    constructor(data: ColorStyleData, engine: PluginEngine);
    /**
     * Set the attributes of a color style.
     *
     * Use `"ColorStyle.setAttributes"` to check if this method is allowed.
     */
    setAttributes(update: Partial<ColorStyleAttributes>): Promise<ColorStyle | null>;
    /**
     * Get plugin data for this color style by key.
     */
    getPluginData(key: string): Promise<string | null>;
    /**
     * Set plugin data on this color style by key.
     *
     * Use `"ColorStyle.setPluginData"` to check if this method is allowed.
     */
    setPluginData(key: string, value: string | null): Promise<void>;
    /**
     * Get all plugin data keys for this color style.
     */
    getPluginDataKeys(): Promise<string[]>;
    /**
     * Deletes the color style from the project.
     *
     * Use `"ColorStyle.remove"` to check if this method is allowed.
     */
    remove(): Promise<void>;
}

declare type ColorStyleAttributes = Prettify<RequiredColorStyleAttributes & Partial<OptionalColorStyleAttributes> & AssetPath>;

declare interface ColorStyleData extends RequiredColorStyleAttributes, OptionalColorStyleAttributes {
    __class: typeof colorStyleDiscriminator;
    id: NodeId;
    name: string;
    path: string;
}

declare const colorStyleDiscriminator: "ColorStyle";

declare interface CommonNodeData extends WithIdTrait, WithReplicaInfoTrait {
    __class: PluginNodeClass;
}

declare type ComponentDragData = Omit<Extract<DragData, {
    type: "componentInstance";
}>, "attributes"> & {
    attributes?: Record<string, unknown>;
};

declare interface ComponentInstanceDragData extends WithOptionalName$1, WithOptionalPreviewImage {
    type: "componentInstance";
    url: string;
    attributes?: Partial<EditableComponentInstanceNodeAttributes>;
}

export declare class ComponentInstanceNode extends NodeMethods implements EditableComponentInstanceNodeAttributes, WithComponentInfoTrait {
    #private;
    readonly __class: ComponentInstanceNodeData["__class"];
    readonly name: string | null;
    readonly visible: boolean;
    readonly locked: boolean;
    readonly componentIdentifier: string;
    readonly insertURL: string | null;
    readonly componentName: string | null;
    readonly controls: ControlAttributes;
    readonly rotation: number;
    readonly opacity: number;
    readonly position: Position;
    readonly top: CSSDimension<CSSUnit.Pixel> | null;
    readonly right: CSSDimension<CSSUnit.Pixel> | null;
    readonly bottom: CSSDimension<CSSUnit.Pixel> | null;
    readonly left: CSSDimension<CSSUnit.Pixel> | null;
    readonly centerX: CSSDimension<CSSUnit.Percentage> | null;
    readonly centerY: CSSDimension<CSSUnit.Percentage> | null;
    readonly width: WidthLength | null;
    readonly height: HeightLength | null;
    readonly maxWidth: WidthConstraint | null;
    readonly minWidth: WidthConstraint | null;
    readonly maxHeight: HeightConstraint | null;
    readonly minHeight: HeightConstraint | null;
    readonly aspectRatio: number | null;
    constructor(rawData: ComponentInstanceNodeData, engine: PluginEngine);

}

declare interface ComponentInstanceNodeData extends CommonNodeData, Partial<DrawableNode>, WithPositionTrait, Partial<WithPinsTrait>, Partial<WithSizeTrait>, Partial<WithSizeConstraintsTrait>, Partial<WithAspectRatioTrait>, Partial<WithControlAttributesTrait>, WithRequiredComponentInfoTrait, Partial<WithNullableComponentInfoTrait>, Partial<WithRotationTrait> {
    __class: "ComponentInstanceNode";
}

export declare class ComponentNode extends NodeMethods implements EditableComponentNodeAttributes, WithComponentInfoTrait {
    readonly __class: ComponentNodeData["__class"];
    readonly name: string | null;
    readonly componentIdentifier: string;
    readonly insertURL: string | null;
    readonly componentName: string | null;
    constructor(rawData: ComponentNodeData, engine: PluginEngine);
}

declare interface ComponentNodeData extends CommonNodeData, Partial<WithNameTrait>, WithRequiredComponentInfoTrait, Partial<WithNullableComponentInfoTrait> {
    __class: "ComponentNode";
}

export declare class ConicGradient implements ConicGradientOptions {
    readonly angle: number;
    readonly x: CSSDimension<CSSUnit.Percentage>;
    readonly y: CSSDimension<CSSUnit.Percentage>;
    readonly stops: readonly ColorStop[];
    constructor(options: ConicGradientOptions);
    cloneWithAttributes(attributes: Partial<ConicGradientOptions>): ConicGradient;
    toCSS(): string;
}

declare const conicGradientClassDiscriminator: "ConicGradient";

declare interface ConicGradientData extends ConicGradientOptions {
    __class: typeof conicGradientClassDiscriminator;
}

declare interface ConicGradientOptions {
    /** 0-360 */
    angle: number;
    /** Relative horizontal position */
    x: CSSDimension<CSSUnit.Percentage>;
    /** Relative vertical position */
    y: CSSDimension<CSSUnit.Percentage>;
    /** Color stops with position */
    stops: readonly ColorStop[];
}

declare interface ContextMenuConfig {
    /**
     * Coordinates of the anchor point.
     */
    location: {
        x: number;
        y: number;
    };
    /**
     * Placement of the menu relative to the anchor point.
     */
    placement?: MenuPlacement;
    /**
     * Sets fixed width for the menu. If not set, the menu width is based on the content.
     */
    width?: number;
}

export declare type ControlAttributes = Record<string, unknown>;

declare const createableNodes: readonly ["FrameNode"];

declare interface CreateArrayField extends ArrayFieldBase, CreateFieldBase, WithOptionalFieldRequired {
    fields: [CreateArrayItemField];
}

declare interface CreateArrayItem {
    /** Data for the fields. */
    fieldData: ArrayItemFieldDataInput | undefined;
}

declare interface CreateArrayItemField extends ArrayItemFieldBase, CreateFieldBase, WithOptionalFieldRequired {
}

declare interface CreateBooleanField extends BooleanFieldBase, CreateFieldBase {
}

declare interface CreateCollectionItem extends BaseCollectionItemData {
    /** The ID of an existing item if updating. Omit if adding. */
    id?: undefined;
    /** Unique on collection level. Required if adding, optional if updating. */
    slug: string;
    /** Localized values for the slug */
    slugByLocale?: LocalizationSourceUpdate;
    /** Data for the fields. */
    fieldData?: FieldDataInput | undefined;
    /** Status of each locale for the resulting localization  group */
    statusByLocale?: LocalizationGroupStatusByLocale;
}

declare interface CreateCollectionReferenceField extends CollectionReferenceFieldBase, CreateFieldBase, WithFieldCollectionId, WithOptionalFieldRequired {
}

declare interface CreateColorField extends ColorFieldBase, CreateFieldBase {
}

declare interface CreateDateField extends DateFieldBase, CreateFieldBase, WithOptionalFieldRequired {
}

declare type CreateEnumCase = WithEnumCaseNameInput;

declare interface CreateEnumField extends EnumFieldBase, CreateFieldBase {
    cases: CreateEnumCase[];
}

export declare type CreateField = CreateBooleanField | CreateColorField | CreateNumberField | CreateStringField | CreateFormattedTextField | CreateImageField | CreateLinkField | CreateDateField | CreateFileField | CreateEnumField | CreateCollectionReferenceField | CreateMultiCollectionReferenceField | CreateFieldDivider | CreateArrayField;

declare type CreateFieldBase = WithFieldName;

declare interface CreateFieldDivider extends FieldDividerBase, CreateFieldBase {
}

declare interface CreateFileField extends FileFieldBase, CreateFieldBase, WithFieldAllowedFileTypes, WithOptionalFieldRequired {
}

declare interface CreateFormattedTextField extends FormattedTextFieldBase, CreateFieldBase, WithOptionalFieldRequired {
}

declare interface CreateImageField extends ImageFieldBase, CreateFieldBase, WithOptionalFieldRequired {
}

declare interface CreateLinkField extends LinkFieldBase, CreateFieldBase, WithOptionalFieldRequired {
}

declare interface CreateMultiCollectionReferenceField extends MultiCollectionReferenceFieldBase, CreateFieldBase, WithFieldCollectionId, WithOptionalFieldRequired {
}

declare type CreateNodeType$1 = (typeof createableNodes)[number];

declare type CreateNodeType = Extends<PluginNodeClass, "FrameNode" | "TextNode">;

declare interface CreateNumberField extends NumberFieldBase, CreateFieldBase {
}

declare interface CreateRedirect extends RedirectAttributes, WithToField {
    /** The id of the redirect, if provided, the redirect will be updated, otherwise a new redirect will be created */
    id?: never;
}

declare interface CreateStringField extends StringFieldBase, CreateFieldBase, WithOptionalFieldRequired {
}

declare type CSSDimension<U extends CSSUnit> = `${number}${U}`;

declare enum CSSUnit {
    Pixel = "px",
    Rem = "rem",
    Em = "em",
    Percentage = "%",
    Fraction = "fr",
    ViewportWidth = "vw",
    ViewportHeight = "vh"
}

export declare type CustomCode = Record<CustomCodeLocation, {
    disabled: boolean;
    html: string | null;
}>;

export declare type CustomCodeLocation = "headStart" | "headEnd" | "bodyStart" | "bodyEnd";

export declare class DateField extends FieldBaseWithRequired {
    readonly type = "date";
}

declare interface DateFieldBase {
    type: DateFieldType;
}

declare interface DateFieldDataEntry {
    type: DateFieldType;
    value: string | undefined;
}

declare interface DateFieldDataEntryInput {
    type: DateFieldType;
    value: string | number | null;
}

declare interface DateFieldDefinitionData extends DateFieldBase, WithFieldRequired, FieldDefinitionBase {
}

declare type DateFieldType = typeof dateFieldType;

declare const dateFieldType = "date";

declare interface DetachedComponentLayersDragData extends WithOptionalName$1, WithOptionalPreviewImage {
    type: "detachedComponentLayers";
    url: string;
    layout?: boolean;
    attributes?: Partial<EditableComponentInstanceNodeAttributes>;
}

declare interface DiagnosticBase {
    message: string;
    span?: DiagnosticSpan;
}

export declare interface DiagnosticSpan {
    /** The first character, counted from the beginning of the file, 0-based. */
    offset: number;
    length: number;
    /** The first character, 0-based. */
    start: ts.LineAndCharacter;
    /** The last character, 0-based. */
    end: ts.LineAndCharacter;
}

declare type DragCompleteCallback = (result: DragCompleteResult) => void;

declare interface DragCompleteError {
    /** Whether the drag was successful or not. */
    status: "error";
    /** Reason for the error, if available. */
    reason?: string;
}

export declare type DragCompleteResult = DragCompleteSuccess | DragCompleteError;

declare interface DragCompleteSuccess {
    /** Whether the drag was successful or not. */
    status: "success";
    /** The inserted node id. */
    nodeId: NodeId;
}

declare type DragData = SvgDragData | ImageDragData | ComponentInstanceDragData | DetachedComponentLayersDragData;

declare type DragEndInfo = DragSessionId & {
    cancelled: boolean;
};

export declare const Draggable: FC<DraggableProps>;

declare interface DraggableProps {
    data: DragData | (() => DragData);
    onDragComplete?: DragCompleteCallback;
    children: ReactElement;
}

declare type DragInfo = DragSessionId & Mouse;

declare interface DragSessionId {
    dragSessionId: string;
}

declare type DragStartInfo = DragSessionId & ElementRect & Mouse;

declare interface DrawableNode extends WithNameTrait, WithVisibleTrait, WithLockedTrait, WithOpacityTrait {
}

declare interface EditableArrayItemAttributes {
    /** Data for the fields. */
    fieldData?: ArrayItemFieldDataInput | undefined;
}

declare interface EditableCollectionItemAttributes extends BaseCollectionItemData {
    /** Unique on collection level. Required if adding, optional if updating. */
    slug?: string | undefined;
    /** Localized values for the slug */
    slugByLocale?: LocalizationSourceUpdate;
    /** Data for the fields. */
    fieldData?: FieldDataInput | undefined;
    /** Status of each locale for the resulting localization  group */
    statusByLocale?: Record<LocaleId, LocalizationGroupStatus>;
}

declare interface EditableCollectionItemAttributesWithId extends EditableCollectionItemAttributes {
    /** The ID of an existing item if updating. Omit if adding. */
    id: NodeId;
}

declare interface EditableComponentInstanceNodeAttributes extends DrawableNode, WithPositionTrait, WithPinsTrait, WithSizeTrait, WithSizeConstraintsTrait, WithAspectRatioTrait, WithControlAttributesTrait, WithRotationTrait {
}

declare type EditableComponentNodeAttributes = WithNameTrait;

declare interface EditableFrameNodeAttributes extends DrawableNode, WithPositionTrait, WithPinsTrait, WithSizeTrait, WithSizeConstraintsTrait, WithAspectRatioTrait, WithBackgroundColorTrait<TraitVariantNode>, WithBackgroundImageTrait<TraitVariantNode>, WithBackgroundGradientTrait<TraitVariantNode>, WithRotationTrait, WithLinkTrait, WithBorderRadiusTrait, WithImageRenderingTrait {
}

/** @deprecated Use `ManagedCollectionFieldInput` instead. */
export declare type EditableManagedCollectionField = ManagedCollectionFieldInputData;

declare interface EditableSVGNodeAttributes extends DrawableNode, WithPositionTrait, WithPinsTrait, WithSizeTrait, WithSVGTrait, WithRotationTrait {
}

declare interface EditableTextNodeAttributes extends DrawableNode, WithPositionTrait, WithPinsTrait, WithSizeTrait, WithSizeConstraintsTrait, WithRotationTrait, WithFontTrait<TraitVariantNode>, WithLinkTrait, WithInlineTextStyleTrait<TraitVariantNode> {
}

declare interface EditableVectorSetItemNodeAttributes extends WithNameTrait, WithVisibleTrait, WithLockedTrait, WithPinsTrait, WithSizeTrait {
}

declare type EditableVectorSetNodeAttributes = WithNameTrait;

declare type EditableWebPageNodeAttributes = object;

declare interface ElementRect {
    elementRect: Rect_2;
    svgRect?: Rect_2;
}

export declare class EnumCase implements WithEnumCaseId, WithEnumCaseName {
    #private;
    get id(): string;
    get name(): string;
    get nameByLocale(): InlineLocalizationValueByLocale;
    constructor(engine: PluginEngine, collectionId: string, fieldId: string, enumCaseData: EnumCaseData);
    /**
     * Update a mutable enum case property, for example the name.
     *
     * Use `"EnumCase.setAttributes"` to check if this method is allowed.
     */
    setAttributes(attributes: UpdateEnumCase): Promise<EnumCase | null>;
    /**
     * Remove the enum case.
     *
     * Use `"EnumCase.remove"` to check if this method is allowed.
     */
    remove(): Promise<void>;
}

export declare interface EnumCaseData extends WithEnumCaseId, WithEnumCaseName {
}

export declare interface EnumCaseData extends WithEnumCaseId, WithEnumCaseName {
}

declare interface EnumCaseDataInput extends WithEnumCaseId, WithEnumCaseNameInput {
}

declare interface EnumCaseDataInputForUpdate extends WithEnumCaseId, WithEnumCaseNameInputForUpdate {
}

export declare class EnumField extends FieldBase {
    #private;
    readonly type = "enum";
    get cases(): readonly EnumCase[];
    constructor(engine: PluginEngine, collectionId: string, data: EnumFieldDefinitionData);
    /**
     * Add a new enum case.
     *
     * Use `"EnumField.addCase"` to check if this method is allowed.
     */
    addCase(attributes: CreateEnumCase): Promise<EnumCase | null>;
    /**
     * Arrange enum cases in a specific order.
     *
     * Use `"EnumField.setCaseOrder"` to check if this method is allowed.
     */
    setCaseOrder(caseIds: string[]): Promise<void>;
}

declare interface EnumFieldBase {
    type: EnumFieldType;
}

declare interface EnumFieldDataEntry {
    type: EnumFieldType;
    value: string;
}

declare interface EnumFieldDataEntryInput {
    type: EnumFieldType;
    value: string;
}

declare interface EnumFieldDefinitionData extends EnumFieldBase, FieldDefinitionBase {
    cases: EnumCaseData[];
}

declare type EnumFieldType = typeof enumFieldType;

declare const enumFieldType = "enum";

declare interface EnvironmentInfo {
    releaseChannel: ReleaseChannel | null;
    isEmployee: boolean;
}

declare const environmentInfoSymbol: unique symbol;

declare type Extends<T, U extends T> = U;

export declare type Field = BooleanField | ColorField | NumberField | StringField | FormattedTextField | ImageField | LinkField | DateField | FieldDivider | UnsupportedField | FileField | EnumField | CollectionReferenceField | MultiCollectionReferenceField | ArrayField;

declare abstract class FieldBase {
    #private;
    abstract readonly type: FieldDefinitionData["type"];
    get id(): string;
    get name(): string;
    constructor(engine: PluginEngine, collectionId: string, data: FieldDefinitionBase);
    /**
     * Use to rename any field:
     *
     * ```ts
     * const updatedField = await field.setAttributes({ name: "New Name" })
     * ```
     *
     * And to set other attributes too, but make sure to narrow based on field's `type` first, as to
     * avoid potential bugs:
     *
     * ```ts
     * if (field.type === "file") await field.setAttributes({ allowedFileTypes: ["txt", "md"] })
     * ```
     *
     * Returns the updated field on success, and `null` in the unlikely event of it being removed
     * between getting it and calling this method.
     *
     * Use `"Field.setAttributes"` to check if this method is allowed.
     */
    setAttributes(attributes: UpdateFieldAttributes<typeof FieldBase>): Promise<typeof FieldBase | null>;
    /**
     * Remove this field.
     *
     * Use `"Field.remove"` to check if this method is allowed.
     */
    remove(): Promise<void>;
}

declare abstract class FieldBaseWithRequired extends FieldBase implements WithFieldRequired {
    #private;
    get required(): boolean;
    constructor(engine: PluginEngine, collectionId: string, data: FieldDefinitionBase & WithFieldRequired);
}

export declare type FieldData = Record<string, FieldDataEntry>;

export declare type FieldDataEntry = BooleanFieldDataEntry | ColorFieldDataEntry | DateFieldDataEntry | EnumFieldDataEntry | FileFieldDataEntry | LinkFieldDataEntry | NumberFieldDataEntry | FormattedTextFieldDataEntry | StringFieldDataEntry | ImageFieldDataEntry | CollectionReferenceFieldDataEntry | MultiCollectionReferenceFieldDataEntry | ArrayFieldDataEntry;

export declare type FieldDataEntryInput = BooleanFieldDataEntryInput | ColorFieldDataEntryInput | DateFieldDataEntryInput | EnumFieldDataEntryInput | FileFieldDataEntryInput | LinkFieldDataEntryInput | NumberFieldDataEntryInput | FormattedTextFieldDataEntryInput | StringFieldDataEntryInput | ImageFieldDataEntryInput | CollectionReferenceFieldDataEntryInput | MultiCollectionReferenceFieldDataEntryInput | ArrayFieldDataEntryInput;

declare type FieldDataEntrySerializable = Exclude<FieldDataEntry, ImageFieldDataEntry | FileFieldDataEntry | ColorFieldDataEntry | ArrayFieldDataEntry> | ImageFieldDataEntrySerializable | FileFieldDataEntrySerializable | ColorFieldDataEntrySerializable | ArrayFieldDataEntrySerializable;

export declare type FieldDataInput = Record<string, FieldDataEntryInput>;

declare interface FieldDefinitionBase extends WithFieldId, WithFieldName {
}

/**
 * Any kind of collection field definition. The field may be unsupported by the
 * plugin API.
 */
declare type FieldDefinitionData = SupportedFieldDefinitionData | FieldDividerDefinitionData | UnsupportedFieldDefinitionData;

export declare class FieldDivider extends FieldBase {
    readonly type = "divider";
}

declare interface FieldDividerBase {
    type: FieldDividerType;
}

declare interface FieldDividerDefinitionData extends FieldDividerBase, FieldDefinitionBase {
}

declare type FieldDividerType = typeof fieldDividerType;

declare const fieldDividerType = "divider";

declare type FieldInput = Prettify<CreateField | UpdateField>;

declare type FieldSerializableData = Record<string, FieldDataEntrySerializable>;

declare class FileAsset implements AssetIdentifier, FileAssetDataFields {
    readonly id: AssetId;
    readonly url: string;
    readonly extension: string | null;
    constructor(data: FileAssetData);
}

declare interface FileAssetData extends AssetIdentifier, FileAssetDataFields {
    __class: typeof fileAssetDiscriminator;
}

declare interface FileAssetDataFields extends AssetData {
    extension: string | null;
}

declare const fileAssetDiscriminator: "FileAsset";

export declare class FileField extends FieldBaseWithRequired implements WithFieldAllowedFileTypes {
    #private;
    readonly type = "file";
    get allowedFileTypes(): string[];
    constructor(engine: PluginEngine, collectionId: string, data: FileFieldDefinitionData);
}

declare interface FileFieldBase {
    type: FileFieldType;
}

declare interface FileFieldDataEntry {
    type: FileFieldType;
    value: FileAsset | undefined;
}

declare interface FileFieldDataEntryInput {
    type: FileFieldType;
    value: string | null;
}

declare interface FileFieldDataEntrySerializable {
    type: FileFieldType;
    value: FileAssetData | undefined;
}

declare interface FileFieldDefinitionData extends FileFieldBase, FieldDefinitionBase, WithFieldAllowedFileTypes, WithFieldRequired {
}

declare type FileFieldType = typeof fileFieldType;

declare const fileFieldType = "file";

export declare type FitContent = "fit-content";

export declare class Font {
    /** An identifier used internally for differentiating fonts. */
    readonly selector: string;
    /** Name of the family the font belongs to. */
    readonly family: string;
    /**
     * Specifies how thin or bold the font appears.
     *
     * Note: This will be `null` for custom fonts since their weight isn't
     * calculated.
     * */
    readonly weight: FontWeight | null;
    /**
     * Specifies if the font is normal or _italic_.
     *
     * Note: This will be `null` for custom fonts since their weight isn't
     * calculated.
     * */
    readonly style: FontStyle | null;
    constructor(data: FontData);
}

declare type FontAttributes = Prettify<Partial<{
    weight: FontWeight;
    style: FontStyle;
}>>;

declare interface FontData {
    __class: "Font";
    selector: FontSelector;
    family: string;
    weight: FontWeight | null;
    style: FontStyle | null;
}

declare type FontSelector = string;

declare type FontStyle = (typeof fontStyles)[number];

declare const fontStyles: readonly ["normal", "italic"];

/**
 * Boldness as an absolute value.
 *
 *  These values are usually associated with the following names:
 * - `100` - Thin
 * - `200` - Extra Light (Ultra Light)
 * - `300` - Light
 * - `400` - Normal
 * - `500` - Medium
 * - `600` - Semi Bold (Demi Bold)
 * - `700` - Bold
 * - `800` - Extra Bold
 * - `900` - Black (Heavy)
 * */
declare type FontWeight = (typeof fontWeights)[number];

declare const fontWeights: readonly [100, 200, 300, 400, 500, 600, 700, 800, 900];

export declare class FormattedTextField extends FieldBaseWithRequired {
    readonly type = "formattedText";
}

declare interface FormattedTextFieldBase {
    type: FormattedTextFieldType;
}

declare interface FormattedTextFieldDataEntry {
    type: FormattedTextFieldType;
    value: string;
    valueByLocale: InlineLocalizationValueByLocale;
}

declare interface FormattedTextFieldDataEntryInput {
    type: FormattedTextFieldType;
    value: string;
    valueByLocale?: LocalizationSourceUpdate;
}

declare interface FormattedTextFieldDefinitionData extends FormattedTextFieldBase, WithFieldRequired, FieldDefinitionBase {
}

declare interface FormattedTextFieldInput extends CreateFormattedTextField, WithIdAndOptionalUserEditable {
}

declare type FormattedTextFieldType = typeof formattedTextFieldType;

declare const formattedTextFieldType = "formattedText";

export declare class FrameNode extends NodeMethods implements EditableFrameNodeAttributes {
    readonly __class: FrameNodeData["__class"];
    readonly name: string | null;
    readonly visible: boolean;
    readonly locked: boolean;
    readonly backgroundColor: ColorStyle | string | null;
    readonly backgroundImage: ImageAsset | null;
    readonly backgroundGradient: LinearGradient | RadialGradient | ConicGradient | null;
    readonly rotation: number;
    readonly opacity: number;
    readonly borderRadius: BorderRadius;
    readonly imageRendering: ImageRendering | null;
    readonly position: Position;
    readonly top: CSSDimension<CSSUnit.Pixel> | null;
    readonly right: CSSDimension<CSSUnit.Pixel> | null;
    readonly bottom: CSSDimension<CSSUnit.Pixel> | null;
    readonly left: CSSDimension<CSSUnit.Pixel> | null;
    readonly centerX: CSSDimension<CSSUnit.Percentage> | null;
    readonly centerY: CSSDimension<CSSUnit.Percentage> | null;
    readonly width: WidthLength | null;
    readonly height: HeightLength | null;
    readonly maxWidth: WidthConstraint | null;
    readonly minWidth: WidthConstraint | null;
    readonly maxHeight: HeightConstraint | null;
    readonly minHeight: HeightConstraint | null;
    readonly aspectRatio: number | null;
    readonly link: string | null;
    readonly linkOpenInNewTab: boolean | null;
    constructor(rawData: FrameNodeData, engine: PluginEngine);
}

declare interface FrameNodeData extends CommonNodeData, Partial<DrawableNode>, WithPositionTrait, Partial<WithPinsTrait>, Partial<WithSizeTrait>, Partial<WithSizeConstraintsTrait>, Partial<WithAspectRatioTrait>, Partial<WithBackgroundColorTrait<TraitVariantData>>, Partial<WithBackgroundImageTrait<TraitVariantData>>, Partial<WithBackgroundGradientTrait<TraitVariantData>>, Partial<WithRotationTrait>, Partial<WithLinkTrait>, Partial<WithBorderRadiusTrait>, Partial<WithImageRenderingTrait> {
    __class: "FrameNode";
}

export declare const framer: FramerPluginAPI;

declare class FramerPluginAPI {
    #private;
    constructor(engine: PluginEngine);
    /** Get the current mode. A plugin can launch in a special mode where only a subset of the API is allowed. */
    get mode(): Mode;
    /**
     * Find out if user's permissions allow them to execute all of `methods`:
     *
     * ```ts
     * if (framer.isAllowedTo("addImage")) await framer.addImage(...)
     * if (framer.isAllowedTo("Collection.setItemOrder")) await collection.setItemOrder(...)
     * ```
     *
     * Note that when the result of the permission check affects the UI, it's better to use the
     * `subscribeToIsAllowedTo` method, or `useIsAllowedTo` if using React.
     */
    isAllowedTo(...methods: [ProtectedMethod, ...ProtectedMethod[]]): boolean;
    /**
     * Subscribe to changes in `framer.isAllowedTo(...methods)`:
     *
     * ```ts
     * console.log(`Initial isAllowed: ${framer.isAllowedTo("addImage")}`)
     * framer.subscribeToIsAllowedTo("addImage", (isAllowed) => {
     *     console.log(`New isAllowed: ${isAllowed}`)
     * })
     * ```
     *
     * Refer to `useIsAllowedTo` for a React hook version of this.
     */
    subscribeToIsAllowedTo(...args: [...methods: [ProtectedMethod, ...ProtectedMethod[]], callback: (isAllowed: boolean) => void]): Unsubscribe$1;
    /** Show the plugin UI. */
    showUI(options?: UIOptions): Promise<void>;
    /** Hide the plugin window, without stopping the plugin. */
    hideUI(): Promise<void>;
    /** Stop the plugin. Throws `FramerPluginClosedError`, which should be ignored. */
    closePlugin(message?: string, options?: ClosePluginOptions): never;
    /** Get the current user info like name and id. */
    getCurrentUser(): Promise<User>;
    /** Get the project info like name and id. */
    getProjectInfo(): Promise<ProjectInfo>;
    /** Get the current selection. */
    getSelection(): Promise<CanvasNode[]>;
    /** Set the current selection. */
    setSelection(nodeIds: string | Iterable<string>): Promise<void>;
    /** Subscribe to selection changes. */
    subscribeToSelection(selectionUpdate: (nodes: CanvasNode[]) => void): Unsubscribe$1;
    /** Get the root of the current canvas. */
    getCanvasRoot(): Promise<CanvasRootNode>;
    /** Subscribe to canvas root changes */
    subscribeToCanvasRoot(rootUpdate: (root: CanvasRootNode) => void): Unsubscribe$1;
    /** Get the current publish info. */
    getPublishInfo(): Promise<PublishInfo>;
    /** Subscribe to publish info changes. */
    subscribeToPublishInfo(publishInfoUpdate: (info: PublishInfo) => void): Unsubscribe$1;
    /** Create a new node on the canvas. */
    createFrameNode(attributes: Partial<EditableFrameNodeAttributes>, parentId?: string): Promise<FrameNode | null>;
    /** Remove nodes from the canvas. */
    removeNodes(nodeIds: NodeId[]): Promise<void>;
    /** @deprecated Use `removeNodes` directly. */
    removeNode(nodeId: NodeId): Promise<void>;
    /** Clone a node. */
    cloneNode(nodeId: NodeId): Promise<AnyNode | null>;
    /** Get a node by its id. */
    getNode(nodeId: NodeId): Promise<AnyNode | null>;
    /** Get the parent of a node. */
    getParent(nodeId: NodeId): Promise<AnyNode | null>;
    /** Get the children of a node. */
    getChildren(nodeId: NodeId): Promise<CanvasNode[]>;
    /** Get the rect of a node */
    getRect(nodeId: NodeId): Promise<Rect | null>;
    /** Pans and zooms the viewport to center a single or group of nodes. */
    zoomIntoView(nodeIds: NodeId | Iterable<NodeId>, options?: ZoomIntoViewOptions): Promise<void>;
    /** Set the attributes of a node. */
    setAttributes(nodeId: NodeId, attributes: Partial<AnyEditableAttributes>): Promise<AnyNode | null>;
    /** Set the parent of a node. */
    setParent(nodeId: NodeId, parentId: NodeId, index?: number | undefined): Promise<void>;
    /** Get all nodes of a certain class. */
    getNodesWithType(type: "FrameNode"): Promise<FrameNode[]>;
    getNodesWithType(type: "TextNode"): Promise<TextNode[]>;
    getNodesWithType(type: "SVGNode"): Promise<SVGNode[]>;
    getNodesWithType(type: "ComponentInstanceNode"): Promise<ComponentInstanceNode[]>;
    getNodesWithType(type: "WebPageNode"): Promise<WebPageNode[]>;
    getNodesWithType(type: "ComponentNode"): Promise<ComponentNode[]>;
    /** Get all nodes with a certain attribute. */
    getNodesWithAttribute<T extends NodeAttributeKey, Node = NodeWithAttribute<T>>(attribute: T): Promise<Node[]>;
    /** Get all nodes with a certain attribute which value is set. */
    getNodesWithAttributeSet<T extends NodeAttributeKey, Node = NodeWithAttribute<T>>(attribute: T): Promise<Node[]>;
    /** Get the image of the current selection or null if there is no image. */
    getImage(): Promise<ImageAsset | null>;
    /** Subscribe to single image selection changes. */
    subscribeToImage(imageUpdate: (image: ImageAsset | null) => void): Unsubscribe$1;
    /** Upload an image, and insert on the canvas. */
    addImage(image: NamedImageAssetInput | File): Promise<void>;
    /** Upload an image, and set on the selected node. */
    setImage(image: NamedImageAssetInput | File): Promise<void>;
    /** Upload an image without assigning it to a property. */
    uploadImage(image: NamedImageAssetInput | File): Promise<ImageAsset>;
    /** Add multiple images, replacing the selected images, or insert on the canvas. */
    addImages(images: readonly NamedImageAssetInput[]): Promise<void>;
    /** Upload multiple images without assigning them to properties. */
    uploadImages(images: readonly NamedImageAssetInput[]): Promise<ImageAsset[]>;
    /** Uploads a file without assigning it to a property. */
    uploadFile(file: NamedFileAssetInput | File): Promise<FileAsset>;
    /** Upload multiple files without assigning them to properties. */
    uploadFiles(files: readonly NamedFileAssetInput[]): Promise<FileAsset[]>;
    /** Add an SVG, replacing the selected SVG, or insert on the canvas. */
    addSVG(svg: SVGData): Promise<void>;
    /** Add a component instance by module URL. */
    addComponentInstance({ url, attributes }: AddComponentInstanceOptions): Promise<ComponentInstanceNode>;
    /** Adds the layers of a component by module URL. */
    addDetachedComponentLayers({ url, layout, attributes, }: AddDetachedComponentLayersOptions): Promise<FrameNode>;
    /** Preload the component layers for detached insertion. */
    preloadDetachedComponentLayers(url: string): Promise<void>;
    preloadImageUrlForInsertion(url: string): Promise<void>;
    preloadDragPreviewImage(url: string): Promise<void>;
    /** Get plaintext of the current selection or null if there is no text. */
    getText(): Promise<string | null>;
    /** Set the text of the current selection or insert it onto the canvas. */
    setText(text: string): Promise<void>;
    /** Add a new text node to the canvas. */
    addText(text: string, options?: AddTextOptions): Promise<void>;
    /**
     * Set Custom HTML to be loaded in the document. A plugin can only set custom HTML once per
     * location.
     */
    setCustomCode(options: SetCustomCodeOptions): Promise<void>;
    /** Get custom HTML settings set by the plugin. */
    getCustomCode(): Promise<CustomCode>;
    /** Subscribe to custom HTML changes set by the plugin. */
    subscribeToCustomCode(callback: (customHTML: CustomCode) => void): Unsubscribe$1;
    /** Subscribe to the current text selection. */
    subscribeToText(callback: (text: string | null) => void): Unsubscribe$1;
    /**
     * Allow any HTML element to become draggable. Different types of drag data can be dropped onto
     * Framer. A function is returned to remove the draggable behavior from the element and to stop
     * all of the added listeners.
     */
    makeDraggable(element: HTMLElement, getDragData: () => DragData, onDragComplete?: DragCompleteCallback): Cleanup;
    /** Get the managed collection that is currently active and selected in the UI. */
    getActiveManagedCollection(): Promise<ManagedCollection>;
    /** @deprecated Use `getActiveManagedCollection` */
    getManagedCollection(): Promise<ManagedCollection>;
    /** Get all collections managed by your plugin. */
    getManagedCollections(): Promise<ManagedCollection[]>;
    /** Get a collection by its id. */
    getCollection(id: NodeId): Promise<Collection | null>;
    /** Get the collection that is currently selected in the UI. */
    getActiveCollection(): Promise<Collection | null>;
    /**
     * Get all collections in the project. This includes collections created by the user or a
     * plugin.
     */
    getCollections(): Promise<Collection[]>;
    /**
     * Display a notification message. The message will be truncated if longer than 120 characters.
     */
    notify: Notify;
    /** Get plugin data by key. */
    getPluginData(key: string): Promise<string | null>;
    /** Set plugin data by key. */
    setPluginData(key: string, value: string | null): Promise<void>;
    /** Get all plugin data keys. */
    getPluginDataKeys(): Promise<string[]>;
    /** Get all color styles in the project. */
    getColorStyles(): Promise<ColorStyle[]>;
    /** Get a specific color style. */
    getColorStyle(id: NodeId): Promise<ColorStyle | null>;
    /** Add a new color style to the project. */
    createColorStyle(attributes: ColorStyleAttributes): Promise<ColorStyle>;
    /** Fired when a color style is added, edited or removed. */
    subscribeToColorStyles(callback: (styles: ColorStyle[]) => void): Unsubscribe$1;
    /** Get all text styles in the project. */
    getTextStyles(): Promise<TextStyle[]>;
    /** Get a specific text style. */
    getTextStyle(id: NodeId): Promise<TextStyle | null>;
    /** Add a new text style to the project. */
    createTextStyle(attributes: TextStyleAttributes): Promise<TextStyle>;
    /** Fired when a text style is added, edited or removed. */
    subscribeToTextStyles(callback: (styles: TextStyle[]) => void): Unsubscribe$1;
    /** Get a specific font via it's family name, and optionally weight and style. */
    getFont(family: string, attributes?: FontAttributes): Promise<Font | null>;
    /** Get all available fonts. */
    getFonts(): Promise<Font[]>;
    /** Get all locales in the current Project */
    getLocales(): Promise<readonly Locale[]>;
    /** Get the default locale of the current Project */
    getDefaultLocale(): Promise<Locale>;
    /**
     * Get the currently active locale.
     *
     * - In "localization" mode, the active locale is the locale selected in the Localizations panel.
     * - In "canvas" mode, the active locale is the locale selected in the toolbar.
     * - Otherwise, the active locale is null.
     */
    getActiveLocale(): Promise<Locale | null>;
    /** Get all localization groups in the current Project */
    getLocalizationGroups(): Promise<readonly LocalizationGroup[]>;
    /** Update localization data */
    setLocalizationData(update: LocalizationData): Promise<SetLocalizationDataResult>;
    /** Get all redirects in the project */
    getRedirects(): Promise<readonly Redirect[]>;
    /** Add new redirects or update existing ones if their IDs match */
    subscribeToRedirects(callback: (redirects: Redirect[]) => void): Unsubscribe$1;
    /** Add new redirects or update existing ones if their IDs match */
    addRedirects(redirects: RedirectInput[]): Promise<Redirect[]>;
    /** Remove a redirect from the project */
    removeRedirects(redirectIds: string[]): Promise<void>;
    /** Set the order of redirects */
    setRedirectOrder(redirectIds: string[]): Promise<void>;
    /** Create a new code file */
    createCodeFile(name: string, code: string): Promise<CodeFile>;
    /** Get an array of all code files  */
    getCodeFiles(): Promise<readonly CodeFile[]>;
    /** Get a specific code file */
    getCodeFile(id: string): Promise<CodeFile | null>;
    /**
     * Lint a code file and return the diagnostics.
     *
     * @param fileName - The name of the code file, must include the extension. Use `*.tsx` for TSX files, otherwise the React JSX syntax will be rejected.
     * @param content - The content of the code file.
     * @param rules - The rules to use for linting.
     */
    lintCode(fileName: string, content: string, rules: LintConfig): Promise<LintDiagnostic[]>;
    /**
     * Type check a code file and return the diagnostics.
     *
     * @param fileName - The name of the code file, must include the extension. Use `*.tsx` for TSX files, otherwise the React JSX syntax will be rejected.
     * @param content - The content of the code file.
     */
    typecheckCode(fileName: string, content: string, compilerOptions?: ts.server.protocol.CompilerOptions): Promise<TypecheckDiagnostic[]>;
    /**
     * Subscribe to changes in code files.
     * This will be called when code files are added, removed, or updated and will return an array of
     * all code files in the project.
     */
    subscribeToCodeFiles(callback: (codeFiles: readonly CodeFile[]) => void): Unsubscribe$1;
    /**
     * Set the plugin's menu, which is shown in the plugin window header.
     */
    setMenu(menuItems: MenuItem[]): Promise<void>;
    /**
     * Show a context menu at the given location.
     */
    showContextMenu(menuItems: MenuItem[], config: ContextMenuConfig): Promise<void>;
    /**
     * Updates the version of the given dependency to the
     * specified version.
     *
     * WARNING: This API is unstable and may change or break in the future
     */
    unstable_ensureMinimumDependencyVersion(packageName: string, version: string): Promise<void>;
}

export declare class FramerPluginClosedError extends Error {
    name: string;
}

export declare class FramerPluginError extends Error {
    name: string;
}

declare const getAiServiceInfoMessageType = "INTERNAL_getAiServiceInfo";

declare const getAiServiceInfoSymbol: unique symbol;

export declare type Gradient = LinearGradient | RadialGradient | ConicGradient;

declare type GradientData = LinearGradientData | RadialGradientData | ConicGradientData;

declare interface HandshakeData {
    origin: string;
    pluginReadyResponse: PluginReadyResponse;
}

export declare type HeightConstraint = CSSDimension<CSSUnit.Pixel | CSSUnit.Percentage | CSSUnit.ViewportHeight>;

export declare type HeightLength = Length | FitContent | CSSDimension<CSSUnit.ViewportHeight>;

export declare class ImageAsset implements ImageDataFields, AssetIdentifier {
    #private;
    readonly id: AssetId;
    readonly url: string;
    readonly thumbnailUrl: string;
    readonly altText: string | undefined;
    readonly resolution: Resolution;
    constructor(data: ImageAssetData, engine: PluginEngine);
    /**
     * Clone this image, optionally overriding its attributes.
     */
    cloneWithAttributes({ altText, resolution, }: Prettify<Partial<Pick<ImageAssetData, "altText" | "resolution">>>): ImageAsset;
    /**
     * Measure this image.
     */
    measure(): Promise<Size>;
    /**
     * Get the data such as the bytes of the image. The bytes can be used to manipulate the pixels
     * of the image.
     */
    getData(): Promise<BytesData>;
    /**
     * Load this image as `ImageBitmap`.
     */
    loadBitmap(): Promise<ImageBitmap>;
    /**
     * Load this image as `HTMLImageElement`.
     */
    loadImage(): Promise<HTMLImageElement>;
}

declare interface ImageAssetData extends AssetIdentifier, ImageDataFields {
    __class: typeof imageAssetDiscriminator;
}

declare const imageAssetDiscriminator: "ImageAsset";

declare interface ImageData_2 extends WithOptionalName, ImageOptions {
}

declare interface ImageDataFields extends AssetData {
    /**
     * Thumbnail URL of the image.
     */
    thumbnailUrl: string;
    /**
     * Optional Alt Text of the image.
     */
    altText?: string;
    /**
     * The resolution set on the image. Defaults to "auto"
     */
    resolution: Resolution;
}

declare interface ImageDragData extends WithOptionalName$1, WithOptionalPreviewImage, ImageOptions {
    type: "image";
    image: string;
}

export declare class ImageField extends FieldBaseWithRequired {
    readonly type = "image";
}

declare interface ImageFieldBase {
    type: ImageFieldType;
}

declare interface ImageFieldDataEntry {
    type: ImageFieldType;
    value: ImageAsset | undefined;
}

declare interface ImageFieldDataEntryInput {
    type: ImageFieldType;
    value: string | null;
    alt?: string;
    altByLocale?: LocalizationSourceUpdate;
}

declare interface ImageFieldDataEntrySerializable {
    type: ImageFieldType;
    value: ImageAssetData | undefined;
}

declare interface ImageFieldDefinitionData extends ImageFieldBase, WithFieldRequired, FieldDefinitionBase {
}

declare type ImageFieldType = typeof imageFieldType;

declare const imageFieldType = "image";

declare interface ImageOptions {
    /**
     * The image rendering to use.
     * Defaults to "auto"
     */
    preferredImageRendering?: ImageRendering;
    /**
     * The alt text to use for the image.
     */
    altText?: string;
    /**
     * The resolution to use for the image.
     * Defaults to "auto"
     */
    resolution?: Resolution;
}

export declare type ImageRendering = "auto" | "pixelated";

export declare type InlineLocalizationValueByLocale = Record<LocaleId, LocalizationValue>;

export declare function isCodeFileComponentExport(exportItem: CodeFileExport): exportItem is CodeFileComponentExport;

export declare function isCodeFileOverrideExport(exportItem: CodeFileExport): exportItem is CodeFileOverrideExport;

export declare function isColorStyle(value: unknown): value is ColorStyle;

export declare function isComponentInstanceNode(node: unknown): node is ComponentInstanceNode;

export declare function isComponentNode(node: unknown): node is ComponentNode;

export declare function isFileAsset(value: unknown): value is FileAsset;

export declare function isFrameNode(node: unknown): node is FrameNode;

export declare function isImageAsset(value: unknown): value is ImageAsset;

export declare function isSVGNode(node: unknown): node is SVGNode;

export declare function isTextNode(node: unknown): node is TextNode;

export declare function isTextStyle(value: unknown): value is TextStyle;

export declare function isVectorSetItemNode(node: unknown): node is VectorSetItemNode;

export declare function isVectorSetNode(node: unknown): node is VectorSetNode;

export declare function isWebPageNode(node: unknown): node is WebPageNode;

declare type KnownNodeClass = Exclude<PluginNodeClass, "UnknownNode">;

export declare type Length = CSSDimension<CSSUnit.Pixel | CSSUnit.Percentage | CSSUnit.Fraction>;

export declare class LinearGradient implements LinearGradientOptions {
    readonly angle: number;
    readonly stops: readonly ColorStop[];
    constructor(options: LinearGradientOptions);
    cloneWithAttributes(attributes: Partial<LinearGradientOptions>): LinearGradient;
    toCSS(): string;
}

declare const linearGradientClassDiscriminator: "LinearGradient";

declare interface LinearGradientData extends LinearGradientOptions {
    __class: typeof linearGradientClassDiscriminator;
}

declare interface LinearGradientOptions {
    /** 0-360 */
    angle: number;
    /** Color stops with position */
    stops: readonly ColorStop[];
}

export declare class LinkField extends FieldBaseWithRequired {
    readonly type = "link";
}

declare interface LinkFieldBase {
    type: LinkFieldType;
}

declare interface LinkFieldDataEntry {
    type: LinkFieldType;
    value: string | undefined;
    valueByLocale: InlineLocalizationValueByLocale;
}

declare interface LinkFieldDataEntryInput {
    type: LinkFieldType;
    value: string | null;
    valueByLocale?: LocalizationSourceUpdate;
}

declare interface LinkFieldDefinitionData extends LinkFieldBase, WithFieldRequired, FieldDefinitionBase {
}

declare type LinkFieldType = typeof linkFieldType;

declare const linkFieldType = "link";

export declare type LintConfig = Record<LintRuleNameValue, LintIssueSeverityValue>;

export declare interface LintDiagnostic extends DiagnosticBase {
    /** The span of the invalid code in the file. */
    span: DiagnosticSpan;
    severity: LintIssueSeverityValue;
    link?: LintLink;
}

declare type LintIssueSeverityValue = "error" | "warning";

export declare interface LintLink {
    url: string;
    text: string;
}

declare type LintRuleNameValue = "forbid-browser-apis";

export declare interface Locale {
    id: LocaleId;
    code: string;
    name: string;
    slug: string;
    fallbackLocaleId?: string;
}

export declare type LocaleId = string;

export declare interface LocalizationData {
    valuesBySource?: Record<LocalizationSourceId, LocalizationSourceUpdate>;
    statusByLocaleByGroup?: Record<LocalizationGroupId, LocalizationGroupStatusByLocale>;
}

export declare interface LocalizationGroup {
    id: LocalizationGroupId;
    name: string;
    type: "collection" | "collection-item" | "component" | "page" | "settings" | "template";
    supportsExcludedStatus: boolean;
    sources: LocalizationSource[];
    statusByLocale: LocalizationGroupStatusByLocale;
}

declare type LocalizationGroupId = string;

export declare type LocalizationGroupStatus = "excluded" | "ready";

export declare type LocalizationGroupStatusByLocale = Record<LocaleId, LocalizationGroupStatus>;

export declare interface LocalizationSource {
    /** A stable ID of the localization source that can be used for updating and synchronizing */
    id: LocalizationSourceId;
    /** The type of value for this source */
    type: LocalizationSourceType;
    /** Current Source value */
    value: string;
    /** Localized values and metadata for each locale */
    valueByLocale: LocalizationValueByLocale;
}

export declare type LocalizationSourceId = string;

declare type LocalizationSourceType = "string" | "formattedText" | "altText" | "slug" | "link";

export declare type LocalizationSourceUpdate = Record<LocaleId, LocalizedValueUpdate>;

declare interface LocalizationStatusByLocaleError {
    groupId: LocalizationGroupId;
    error: string;
}

declare type LocalizationValue = LocalizationValueNew | LocalizationValueNeedsReview | LocalizationValueDone | LocalizationValueWarning;

declare interface LocalizationValueBase {
    /** A `value` of `null` means that the value explicitly falls back to the fallback locale */
    value: string | null;
    lastEdited: number;
    /**
     * Whether the value is read only and therefore cannot be updated.
     *
     * For example, this is the case for localized values that were set
     * when syncing a managed collection. To update these values, you must
     * sync using the plugin that manages the collection.
     */
    readonly: boolean;
}

export declare type LocalizationValueByLocale = Record<LocaleId, LocalizationValue>;

declare interface LocalizationValueDone extends LocalizationValueBase {
    status: "done";
}

declare interface LocalizationValueError {
    sourceId: LocalizationSourceId;
    localeId: LocaleId | null;
    error: string;
}

declare interface LocalizationValueNeedsReview extends LocalizationValueBase {
    status: "needsReview";
}

declare interface LocalizationValueNew {
    value: null;
    status: "new";
}

declare interface LocalizationValueWarning extends LocalizationValueBase {
    status: "warning";
    warning: string;
}

export declare type LocalizedValueStatus = LocalizationValue["status"];

export declare type LocalizedValueUpdate = {
    action: "set";
    value: string;
    needsReview?: boolean;
} | {
    action: "clear";
} | {
    action: "ignore";
    needsReview?: boolean;
};

declare interface ManagedArrayFieldInput extends CreateArrayField, WithIdAndOptionalUserEditable {
    fields: [ManagedArrayItemFieldInput];
}

declare interface ManagedArrayItemFieldInput extends CreateArrayItemField, WithIdAndOptionalUserEditable {
}

declare interface ManagedBooleanFieldInput extends CreateBooleanField, WithIdAndOptionalUserEditable {
}

export declare class ManagedCollection {
    #private;
    readonly id: NodeId;
    readonly name: string;
    /**
     * @deprecated Use `managedBy` instead and the [Permissions
     * API](https://www.framer.com/developers/plugins-permissions) to check if users can edit the
     * collection.
     */
    readonly readonly: boolean;
    /**
     * Collections managed by other plugins should are read-only.
     */
    readonly managedBy: ManagedCollectionManagedBy;
    constructor(data: CollectionData, engine: PluginEngine);
    /**
     * Get item keys in their set order.
     */
    getItemIds(): Promise<string[]>;
    /**
     * Arrange items in a specific order.
     *
     * Use `"ManagedCollection.setItemOrder"` to check if this method is allowed.
     */
    setItemOrder(ids: string[]): Promise<void>;
    /**
     * Get all fields.
     */
    getFields(): Promise<ManagedCollectionField[]>;
    /**
     * Create, update or remove all fields in one go.
     *
     * Use `"ManagedCollection.setFields"` to check if this method is allowed.
     */
    setFields(fields: ManagedCollectionFieldInput[]): Promise<void>;
    /**
     * Add new items or update existing ones if their IDs match.
     *
     * Use `"ManagedCollection.addItems"` to check if this method is allowed.
     */
    addItems(items: ManagedCollectionItemInput[]): Promise<void>;
    /**
     * Remove items by their ID.
     *
     * Use `"ManagedCollection.removeItems"` to check if this method is allowed.
     */
    removeItems(itemIds: string[]): Promise<void>;
    /**
     * Make this the active collection.
     */
    setAsActive(): Promise<void>;
    /**
     * Set plugin data by key.
     *
     * Use `"ManagedCollection.setPluginData"` to check if this method is allowed.
     */
    setPluginData(key: string, value: string | null): Promise<void>;
    /**
     * Get plugin data by key.
     */
    getPluginData(key: string): Promise<string | null>;
    /**
     * Get all plugin data keys.
     */
    getPluginDataKeys(): Promise<string[]>;
}

/**
 * Any kind of collection field definition that was created by a plugin and is
 * supported by the API.
 */
export declare type ManagedCollectionField = SupportedFieldDefinitionData & WithUserEditable;

export declare type ManagedCollectionFieldInput = Exclude<ManagedCollectionFieldInputData, ManagedEnumFieldInput> | ManagedEnumFieldInputForSetFields;

declare type ManagedCollectionFieldInputData = ManagedBooleanFieldInput | ManagedColorFieldInput | ManagedNumberFieldInput | ManagedStringFieldInput | FormattedTextFieldInput | ManagedImageFieldInput | ManagedLinkFieldInput | ManagedDateFieldInput | ManagedFileFieldInput | ManagedEnumFieldInput | ManagedCollectionReferenceFieldInput | ManagedMultiCollectionReferenceFieldInput | ManagedArrayFieldInput;

export declare interface ManagedCollectionItemInput extends BaseCollectionItemData {
    /** Required unique ID of your choice. Using an ID instead of the slug helps avoid data loss. */
    id: string;
    /** Unique on collection level. */
    slug: string;
    /** Localized values for the slug */
    slugByLocale?: LocalizationSourceUpdate;
    /** Data for the fields. */
    fieldData: FieldDataInput;
    /** Status of each locale for the resulting localization  group */
    statusByLocale?: LocalizationGroupStatusByLocale;
}

declare type ManagedCollectionManagedBy = "thisPlugin" | "anotherPlugin";

declare interface ManagedCollectionReferenceFieldInput extends CreateCollectionReferenceField, WithIdAndOptionalUserEditable {
}

declare interface ManagedColorFieldInput extends CreateColorField, WithIdAndOptionalUserEditable {
}

declare interface ManagedDateFieldInput extends CreateDateField, WithIdAndOptionalUserEditable {
}

declare interface ManagedEnumFieldInput extends EnumFieldBase, CreateFieldBase, WithIdAndOptionalUserEditable {
    cases: EnumCaseDataInput[];
}

declare interface ManagedEnumFieldInputForSetFields extends Omit<ManagedEnumFieldInput, "cases"> {
    cases: EnumCaseDataInputForUpdate[];
}

declare interface ManagedFileFieldInput extends CreateFileField, WithIdAndOptionalUserEditable {
}

declare interface ManagedImageFieldInput extends CreateImageField, WithIdAndOptionalUserEditable {
}

declare interface ManagedLinkFieldInput extends CreateLinkField, WithIdAndOptionalUserEditable {
}

declare interface ManagedMultiCollectionReferenceFieldInput extends CreateMultiCollectionReferenceField, WithIdAndOptionalUserEditable {
}

declare interface ManagedNumberFieldInput extends CreateNumberField, WithIdAndOptionalUserEditable {
}

declare interface ManagedStringFieldInput extends CreateStringField, WithIdAndOptionalUserEditable {
}

export declare type MenuItem = NormalMenuItem | SeparatorMenuItem;

declare type MenuItemSerializable = NormalMenuItemSerializable | SeparatorMenuItem;

declare type MenuPlacement = MenuPlacementVertical | MenuPlacementHorizontal | `${MenuPlacementVertical}-${MenuPlacementHorizontal}`;

declare type MenuPlacementHorizontal = "left" | "right";

declare type MenuPlacementVertical = "top" | "bottom";

declare type MessageApiDragData = ComponentDragData | OtherDragData;

declare type Method = keyof {
    [K in keyof AllMembers as AllMembers[K] extends (...args: any) => unknown ? K : never]: string;
};

declare const methodToMessageTypes: {
    readonly addComponentInstance: ["addComponentInstance"];

    readonly addDetachedComponentLayers: ["addDetachedComponentLayers"];
    readonly addImage: ["addImage"];
    readonly addImages: ["addImages"];
    readonly addSVG: ["addSVG"];
    readonly addText: ["addText"];
    readonly addRedirects: ["addRedirects"];
    readonly getRedirects: [];
    readonly removeRedirects: ["removeRedirects"];
    readonly setRedirectOrder: ["setRedirectOrder"];
    readonly subscribeToRedirects: [];
    readonly cloneNode: ["cloneNode"];
    readonly closePlugin: [];
    readonly createColorStyle: ["createColorStyle"];
    readonly createFrameNode: ["createNode"];
    readonly createTextNode: ["createNode"];
    readonly createTextStyle: ["createTextStyle"];
    readonly getActiveCollection: [];
    readonly getActiveLocale: [];
    readonly getActiveManagedCollection: [];
    readonly getCanvasRoot: [];
    readonly getChildren: [];
    readonly getCollection: [];
    readonly getCollections: [];
    readonly getColorStyle: [];
    readonly getColorStyles: [];
    readonly getCurrentUser: [];
    readonly getCustomCode: [];
    readonly getDefaultLocale: [];
    readonly getFont: [];
    readonly getFonts: [];
    readonly getImage: [];
    readonly getLocales: [];
    readonly getLocalizationGroups: [];
    readonly getManagedCollection: [];
    readonly getManagedCollections: [];
    readonly getNode: [];
    readonly getNodesWithAttribute: [];
    readonly getNodesWithAttributeSet: [];
    readonly getNodesWithType: [];
    readonly getParent: [];
    readonly getPluginData: [];
    readonly getPluginDataKeys: [];
    readonly getProjectInfo: [];
    readonly getPublishInfo: [];
    readonly getRect: [];
    readonly getSelection: [];
    readonly getText: [];
    readonly getTextStyle: [];
    readonly getTextStyles: [];
    readonly hideUI: [];

    readonly makeDraggable: ["onDragEnd", "onDragStart", "onDrag", "setDragData", "preloadDetachedComponentLayers", "preloadImageUrlForInsertion", "preloadDragPreviewImage"];
    readonly notify: [];
    readonly preloadDetachedComponentLayers: ["preloadDetachedComponentLayers"];
    readonly preloadDragPreviewImage: ["preloadDragPreviewImage"];
    readonly preloadImageUrlForInsertion: ["preloadImageUrlForInsertion"];
    readonly removeNode: ["removeNodes2"];
    readonly removeNodes: ["removeNodes2"];
    readonly setAttributes: ["setAttributes"];
    readonly setCustomCode: ["setCustomCode"];
    readonly setImage: ["setImage"];
    readonly setLocalizationData: ["setLocalizationData"];
    readonly setMenu: [];
    readonly showContextMenu: [];
    readonly setParent: ["setParent"];
    readonly setPluginData: ["setPluginData"];
    readonly setSelection: [];
    readonly setText: ["setText"];

    readonly showUI: [];
    readonly subscribeToCanvasRoot: [];
    readonly subscribeToColorStyles: [];
    readonly subscribeToCustomCode: [];
    readonly subscribeToImage: [];
    readonly subscribeToPublishInfo: [];
    readonly subscribeToSelection: [];
    readonly subscribeToText: [];
    readonly subscribeToTextStyles: [];
    readonly createCodeFile: ["createCodeFile"];
    readonly unstable_ensureMinimumDependencyVersion: ["unstable_ensureMinimumDependencyVersion"];
    readonly getCodeFiles: [];
    readonly getCodeFile: [];
    readonly subscribeToCodeFiles: [];
    readonly subscribeToOpenCodeFile: [];
    readonly uploadFile: [];
    readonly uploadFiles: [];
    readonly uploadImage: [];
    readonly uploadImages: [];
    readonly zoomIntoView: [];
    readonly "ComponentInstanceNode.getRuntimeError": [];
    readonly "ImageAsset.cloneWithAttributes": [];
    readonly "ImageAsset.getData": [];
    readonly "ImageAsset.loadBitmap": [];
    readonly "ImageAsset.loadImage": [];
    readonly "ImageAsset.measure": [];
    readonly "CodeFile.remove": ["removeCodeFile"];
    readonly "CodeFile.rename": ["renameCodeFile"];
    readonly "CodeFile.setFileContent": ["setCodeFileContent"];
    readonly "CodeFile.getVersions": [];


    readonly "CodeFile.lint": [];
    readonly "CodeFile.typecheck": [];
    readonly "CodeFileVersion.getContent": [];



    readonly "Field.remove": ["removeCollectionFields"];
    readonly "Field.setAttributes": ["addCollectionFields"];
    readonly "EnumCase.remove": ["removeEnumCase"];
    readonly "EnumCase.setAttributes": ["updateEnumCase"];
    readonly "EnumField.addCase": ["addEnumCase"];
    readonly "EnumField.setCaseOrder": ["setEnumCaseOrder"];
    readonly "Collection.addFields": ["addCollectionFields"];
    readonly "Collection.addItems": ["addCollectionItems2"];
    readonly "Collection.getFields": [];
    readonly "Collection.getItems": [];
    readonly "Collection.getPluginData": [];
    readonly "Collection.getPluginDataKeys": [];
    readonly "Collection.removeFields": ["removeCollectionFields"];
    readonly "Collection.removeItems": ["removeCollectionItems"];
    readonly "Collection.setAsActive": [];
    readonly "Collection.setFieldOrder": ["setCollectionFieldOrder"];
    readonly "Collection.setItemOrder": ["setCollectionItemOrder"];
    readonly "Collection.setPluginData": ["setPluginDataForNode"];
    readonly "CollectionItem.getPluginData": [];
    readonly "CollectionItem.getPluginDataKeys": [];
    readonly "CollectionItem.remove": ["removeCollectionItems"];
    readonly "CollectionItem.setAttributes": ["setCollectionItemAttributes2"];
    readonly "CollectionItem.setPluginData": ["setPluginDataForNode"];
    readonly "ManagedCollection.addItems": ["addManagedCollectionItems2"];
    readonly "ManagedCollection.getFields": [];
    readonly "ManagedCollection.getItemIds": [];
    readonly "ManagedCollection.getPluginData": [];
    readonly "ManagedCollection.getPluginDataKeys": [];
    readonly "ManagedCollection.removeItems": ["removeManagedCollectionItems"];
    readonly "ManagedCollection.setAsActive": [];
    readonly "ManagedCollection.setFields": ["setManagedCollectionFields"];
    readonly "ManagedCollection.setItemOrder": ["setManagedCollectionItemOrder"];
    readonly "ManagedCollection.setPluginData": ["setPluginDataForNode"];
    readonly "Node.clone": ["cloneNode"];
    readonly "Node.getChildren": [];
    readonly "Node.getNodesWithAttribute": [];
    readonly "Node.getNodesWithAttributeSet": [];
    readonly "Node.getNodesWithType": [];
    readonly "Node.getParent": [];
    readonly "Node.getPluginData": [];
    readonly "Node.getPluginDataKeys": [];
    readonly "Node.getRect": [];
    readonly "Node.remove": ["removeNodes2"];
    readonly "Node.select": [];
    readonly "Node.setAttributes": ["setAttributes"];
    readonly "Node.setPluginData": ["setPluginDataForNode"];
    readonly "Node.walk": [];
    readonly "Node.zoomIntoView": [];
    readonly "TextNode.getText": [];
    readonly "TextNode.setText": ["setTextForNode"];
    readonly "ColorStyle.getPluginData": [];
    readonly "ColorStyle.getPluginDataKeys": [];
    readonly "ColorStyle.remove": ["removeColorStyle"];
    readonly "ColorStyle.setAttributes": ["setColorStyleAttributes"];
    readonly "ColorStyle.setPluginData": ["setPluginDataForNode"];
    readonly "TextStyle.getPluginData": [];
    readonly "TextStyle.getPluginDataKeys": [];
    readonly "TextStyle.remove": ["removeTextStyle"];
    readonly "TextStyle.setAttributes": ["setTextStyleAttributes"];
    readonly "TextStyle.setPluginData": ["setPluginDataForNode"];
    readonly [getAiServiceInfoSymbol]: [];
    readonly [sendTrackingEventSymbol]: [];
};

export declare type Mode = keyof typeof allModesRecord;

declare interface Mouse {
    mouse: Point;
}

export declare class MultiCollectionReferenceField extends FieldBaseWithRequired implements WithFieldCollectionId {
    #private;
    readonly type = "multiCollectionReference";
    get collectionId(): string;
    constructor(engine: PluginEngine, collectionId: string, data: MultiCollectionReferenceFieldDefinitionData);
}

declare interface MultiCollectionReferenceFieldBase {
    type: MultiCollectionReferenceFieldType;
}

declare interface MultiCollectionReferenceFieldDataEntry {
    type: MultiCollectionReferenceFieldType;
    value: readonly string[];
}

declare interface MultiCollectionReferenceFieldDataEntryInput {
    type: MultiCollectionReferenceFieldType;
    value: readonly string[] | null;
}

declare interface MultiCollectionReferenceFieldDefinitionData extends MultiCollectionReferenceFieldBase, FieldDefinitionBase, WithFieldCollectionId, WithFieldRequired {
}

declare type MultiCollectionReferenceFieldType = typeof multiCollectionReferenceFieldType;

declare const multiCollectionReferenceFieldType = "multiCollectionReference";

declare type NamedAssetTransfer = AssetDataTransfer & WithOptionalName;

declare interface NamedFileAssetInput extends WithOptionalName {
    file: AssetInput;
}

declare interface NamedImageAssetInput extends ImageData_2 {
    image: AssetInput;
}

declare type NamedImageTransfer = AssetDataTransfer & ImageData_2;

declare type NamespaceMembers<Class, Namespace extends string, Parent = undefined> = {
    [Member in Exclude<keyof Class, keyof Parent> as Member extends string ? `${Namespace}.${Member}` : never]: Class[Member];
};

export declare type NodeAttributeKey = Prettify<Exclude<keyof AllTraits<TraitVariantNode>, "id" | "children">>;

declare interface NodeClassToEditableAttributes {
    FrameNode: EditableFrameNodeAttributes;
    TextNode: EditableTextNodeAttributes;
    SVGNode: EditableSVGNodeAttributes;
    ComponentInstanceNode: EditableComponentInstanceNodeAttributes;
    WebPageNode: EditableWebPageNodeAttributes;
    ComponentNode: EditableComponentNodeAttributes;
    VectorSetNode: EditableVectorSetNodeAttributes;
    VectorSetItemNode: EditableVectorSetItemNodeAttributes;
    UnknownNode: object;
}

export declare type NodeId = string;

declare abstract class NodeMethods implements WithIdTrait {
    #private;
    abstract readonly __class: PluginNodeClass;
    readonly id: NodeId;
    constructor(data: SomeNodeData, engine: PluginEngine);
    get isReplica(): boolean;
    /**
     * Remove this node.
     *
     * Use `"Node.remove"` to check if this method is allowed.
     */
    remove(): Promise<void>;
    /**
     * Select this node.
     */
    select(): Promise<void>;
    /**
     * Clone this node.
     *
     * Use `"Node.clone"` to check if this method is allowed.
     */
    clone(): Promise<(typeof NodeMethods)["__class"] extends "UnknownNode" ? never : typeof NodeMethods | null>;
    /**
     * Set the attributes of this node.
     *
     * Use `"Node.setAttributes"` to check if this method is allowed.
     */
    setAttributes(update: Partial<NodeClassToEditableAttributes[(typeof NodeMethods)["__class"]]>): Promise<(typeof NodeMethods)["__class"] extends "UnknownNode" ? never : typeof NodeMethods | null>;
    /**
     * Get the bounding box of this node.
     */
    getRect(): Promise<Rect | null>;
    /**
     * Pans and zooms the viewport to center the node.
     */
    zoomIntoView(options?: ZoomIntoViewOptions): Promise<void>;
    /**
     * Get the parent of this node.
     */
    getParent(): Promise<AnyNode | null>;
    /**
     * Get the children of this node.
     */
    getChildren(): Promise<CanvasNode[]>;
    /**
     * Get `type` descendants of this node.
     */
    getNodesWithType(type: "FrameNode"): Promise<FrameNode[]>;
    getNodesWithType(type: "TextNode"): Promise<TextNode[]>;
    getNodesWithType(type: "SVGNode"): Promise<SVGNode[]>;
    getNodesWithType(type: "ComponentInstanceNode"): Promise<ComponentInstanceNode[]>;
    getNodesWithType(type: "WebPageNode"): Promise<WebPageNode[]>;
    getNodesWithType(type: "ComponentNode"): Promise<ComponentNode[]>;
    /**
     * Get the descendants of this node that support `attribute`.
     */
    getNodesWithAttribute<T extends NodeAttributeKey, Node = NodeWithAttribute<T>>(attribute: T): Promise<Node[]>;
    /**
     * Get the descendants of this node that have `attribute` set.
     */
    getNodesWithAttributeSet<T extends NodeAttributeKey, Node = NodeWithAttribute<T>>(attribute: T): Promise<Node[]>;
    /**
     * Walk this node and its descendants recursively.
     */
    walk(this: AnyNode): AsyncGenerator<AnyNode>;
    /**
     * Get plugin data by key.
     */
    getPluginData(key: string): Promise<string | null>;
    /**
     * Set plugin data by key.
     *
     * Use `"Node.setPluginData"` to check if this method is allowed.
     */
    setPluginData(key: string, value: string | null): Promise<void>;
    /**
     * Get all plugin data keys.
     */
    getPluginDataKeys(): Promise<string[]>;
}

export declare type NodeRuntimeErrorResult = {
    type: "ModuleRuntimeError" | "ReactRenderingError";
    message: string;
};

declare type NodeWithAttribute<T extends NodeAttributeKey> = Extract<AnyNode, Record<T, unknown>>;

export declare interface NormalMenuItem {
    type?: never;
    label: string;
    secondaryLabel?: string;
    enabled?: boolean;
    visible?: boolean;
    checked?: boolean;
    submenu?: MenuItem[];
    onAction?: () => void;
}

declare type NormalMenuItemSerializable = Omit<NormalMenuItem, "onAction" | "submenu"> & {
    actionId?: number;
    submenu?: MenuItemSerializable[];
};

declare interface Notification_2 {
    close: () => Promise<void>;
}
export { Notification_2 as Notification }

declare type NotificationCloseReason = "timeoutReachedOrDismissed" | "actionButtonClicked";

declare type NotificationVariant = "info" | "success" | "error" | "warning";

declare type Notify = (message: string, options?: NotifyOptions) => Notification_2;

declare interface NotifyOptions extends NotifyOptionsBase {
    /** A button to be displayed on the notification */
    button?: {
        /** The text of the button */
        text: string;
        /** Click handler when the button is pressed */
        onClick: () => void;
    };
    /** A function that is called when the notification disappears */
    onDisappear?: VoidFunction;
}

declare interface NotifyOptionsBase {
    /** The Notification variant for styling of the notification. Defaults to "info" */
    variant?: NotificationVariant;
    durationMs?: number;
}

declare interface NotifyOptionsData extends NotifyOptionsBase {
    buttonText?: string;
    notificationId: string;
}

export declare class NumberField extends FieldBase {
    readonly type = "number";
}

declare interface NumberFieldBase {
    type: NumberFieldType;
}

declare interface NumberFieldDataEntry {
    type: NumberFieldType;
    value: number;
}

declare type NumberFieldDataEntryInput = NumberFieldDataEntry;

declare interface NumberFieldDefinitionData extends NumberFieldBase, FieldDefinitionBase {
}

declare type NumberFieldType = typeof numberFieldType;

declare const numberFieldType = "number";

declare type OptimizationStatus = "optimizing" | "optimized" | "error";

declare interface OptionalColorStyleAttributes {
    dark: string | null;
}

declare type OtherDragData = Exclude<DragData, {
    type: "componentInstance";
}>;

declare const otherNodes: readonly ["SVGNode", "WebPageNode", "ComponentNode", "VectorSetNode", "VectorSetItemNode", "UnknownNode", "ComponentInstanceNode", "TextNode"];

declare type OtherNodeType = (typeof otherNodes)[number];

declare type PartialNodeData = AnyNode | Partial<AnyNodeData>;

declare type PerMethodPermissionMap = {
    [K in ProtectedMethod]: boolean;
};

declare type PermissionMap = {
    [K in keyof PluginMessageAPI]: boolean;
};

declare class PluginEngine {
    methodInvocationId: number;
    notificationId: number;
    readonly postMessage: PostMessage;
    readonly methodResponseHandlers: Map<number, {
        resolve: (value: any) => void;
        reject: (error: FramerPluginError) => void;
    }>;
    readonly mode: Mode;
    readonly subscriptions: Map<"image" | "publishInfo" | "selection" | "canvasRoot" | "theme" | "text" | "customCode" | "colorStyles" | "textStyles" | "redirects" | "codeFiles" | "openCodeFile", Set<(value: any) => void>>;
    perMethodPermissionMap: PerMethodPermissionMap;
    readonly permissionSubscriptions: Set<VoidFunction>;
    readonly messageTypesCheckedInIsAllowedTo: Set<ProtectedMessageType>;
    showUncheckedPermissionToasts: boolean;
    readonly environmentInfo: EnvironmentInfo | null;
    menuItemOnActionCallbackMap: Map<number, () => void>;
    contextMenuItemOnActionCallbackMap: Map<number, () => void>;
    constructor(handshakeData?: HandshakeData | undefined);
    invoke<MessageType extends keyof PluginMessageAPI>(messageType: MessageType, ...args: Parameters<PluginMessageAPI[MessageType]>): Promise<Awaited<ReturnType<PluginMessageAPI[MessageType]>>>;
    invokeTransferable<MessageType extends keyof PluginMessageAPI>(messageType: MessageType, transfer: Transferable[] | undefined, ...args: Parameters<PluginMessageAPI[MessageType]>): Promise<Awaited<ReturnType<PluginMessageAPI[MessageType]>>>;
    subscribe<Topic extends PluginSubscriptionTopic>(topic: Topic, callback: (data: Extract<PluginSubscriptionEvent, {
        topic: Topic;
    }>["payload"]) => void): Unsubscribe;
    onMessage: (event: MessageEvent) => void;
    private getOnActionFromCallbackMap;
    applyPluginTheme: (theme: Theme) => void;
    cloneNode(nodeId: NodeId): Promise<AnyNode | null>;
    setAttributes(nodeId: NodeId, attributes: Partial<AnyEditableAttributes>): Promise<AnyNode | null>;
    getParent(nodeId: NodeId): Promise<AnyNode | null>;
    getChildren(nodeId: NodeId): Promise<CanvasNode[]>;
    notify: Notify;
    setMenu(menuItems: MenuItem[]): Promise<void>;
    showContextMenu(menuItems: MenuItem[], config: ContextMenuConfig): Promise<void>;
}

declare interface PluginMessageAPI {
    hideUI: FramerPluginAPI["hideUI"];
    closePlugin: (...parameters: Parameters<FramerPluginAPI["closePlugin"]>) => Promise<void>;
    removeNode: FramerPluginAPI["removeNode"];
    removeNodes: FramerPluginAPI["removeNodes"];
    addSVG: FramerPluginAPI["addSVG"];
    getRect: FramerPluginAPI["getRect"];
    setText: FramerPluginAPI["setText"];
    getText: FramerPluginAPI["getText"];
    addText: FramerPluginAPI["addText"];
    preloadDetachedComponentLayers: FramerPluginAPI["preloadDetachedComponentLayers"];
    preloadImageUrlForInsertion: FramerPluginAPI["preloadImageUrlForInsertion"];
    preloadDragPreviewImage: FramerPluginAPI["preloadDragPreviewImage"];
    setCustomCode: FramerPluginAPI["setCustomCode"];
    getCustomCode: FramerPluginAPI["getCustomCode"];
    setPluginData: FramerPluginAPI["setPluginData"];
    getPluginData: FramerPluginAPI["getPluginData"];
    getPluginDataKeys: FramerPluginAPI["getPluginDataKeys"];
    getLocales: FramerPluginAPI["getLocales"];
    getDefaultLocale: FramerPluginAPI["getDefaultLocale"];
    getActiveLocale: FramerPluginAPI["getActiveLocale"];
    getLocalizationGroups: FramerPluginAPI["getLocalizationGroups"];
    setLocalizationData: FramerPluginAPI["setLocalizationData"];
    unstable_ensureMinimumDependencyVersion: FramerPluginAPI["unstable_ensureMinimumDependencyVersion"];
    showUI: (options?: UIOptions) => Promise<void>;
    notify: (message: string, options: NotifyOptionsData) => Promise<NotificationCloseReason>;
    closeNotification: (notificationId: string) => Promise<void>;
    getCurrentUser(): Promise<ApiVersion1User>;
    getCurrentUser2(): Promise<User>;
    getProjectInfo(): Promise<ApiVersion1ProjectInfo>;
    getProjectInfo2(): Promise<ProjectInfo>;
    getSelection: () => Promise<SomeNodeData[]>;
    setSelection: (nodeIds: NodeId[]) => Promise<void>;
    getCanvasRoot: () => Promise<SomeNodeData>;
    getPublishInfo: () => Promise<PublishInfo>;
    createNode: (type: CreateNodeType, parentId: NodeId | null, attributes: Record<string, unknown>) => Promise<SomeNodeData | null>;
    cloneNode: (nodeId: NodeId) => Promise<SomeNodeData | null>;
    getNode: (nodeId: NodeId) => Promise<SomeNodeData | null>;
    getParent: (nodeId: NodeId) => Promise<SomeNodeData | null>;
    getChildren: (nodeId: NodeId) => Promise<SomeNodeData[]>;
    removeNodes2: (ids: NodeId[]) => Promise<void>;
    zoomIntoView: (nodeIds: NodeId[], options?: ZoomIntoViewOptions) => Promise<void>;
    setAttributes: (nodeId: NodeId, attributes: Record<string, unknown>) => Promise<SomeNodeData | null>;
    getTextForNode(nodeId: NodeId): Promise<string | null>;
    setTextForNode(nodeId: NodeId, text: string): Promise<void>;
    getSVGForNode: (nodeId: NodeId) => Promise<string | null>;
    getNodesWithType: (nodeId: NodeId | null, type: KnownNodeClass) => Promise<SomeNodeData[]>;
    getNodesWithAttribute: (nodeId: NodeId | null, attribute: string) => Promise<SomeNodeData[]>;
    getNodesWithAttributeSet: (nodeId: NodeId | null, attribute: string) => Promise<SomeNodeData[]>;
    addImages: (image: readonly NamedImageTransfer[]) => Promise<void>;
    getImage(): Promise<ImageAssetData | null>;
    addImage(image: NamedImageTransfer): Promise<void>;
    setImage(image: NamedImageTransfer): Promise<void>;
    uploadImage(image: NamedImageTransfer): Promise<ImageAssetData>;
    uploadImages: (image: readonly NamedImageTransfer[]) => Promise<ImageAssetData[]>;
    uploadFile: (file: NamedAssetTransfer) => Promise<FileAssetData>;
    uploadFiles: (files: readonly NamedAssetTransfer[]) => Promise<FileAssetData[]>;
    getImageData: (image: AssetIdentifier & Partial<Pick<ImageAssetData, "resolution">>) => Promise<BytesData>;
    setParent: (nodeId: NodeId, parentId: NodeId, index?: number) => Promise<void>;
    addComponentInstance: (options: {
        url: string;
        attributes?: Partial<Record<string, unknown>>;
    }) => Promise<SomeNodeData>;
    addDetachedComponentLayers: (options: {
        url: string;
        layout?: boolean;
        attributes?: Partial<Record<string, unknown>>;
    }) => Promise<SomeNodeData>;
    setDragData: (dragSessionId: string, dragData: MessageApiDragData) => Promise<void>;
    onDragStart: (info: DragStartInfo) => Promise<void>;
    onDrag: (info: DragInfo) => Promise<string | null>;
    onDragEnd: (info: DragEndInfo) => Promise<DragCompleteResult>;
    onPointerDown: () => Promise<void>;
    getActiveManagedCollection: () => Promise<CollectionData>;
    /** @deprecated Use getActiveManagedCollection */
    getManagedCollection: () => Promise<CollectionData>;
    getManagedCollections: () => Promise<CollectionData[]>;
    getManagedCollectionItemIds: (id: NodeId) => Promise<string[]>;
    setManagedCollectionItemOrder: (id: NodeId, ids: string[]) => Promise<void>;
    setManagedCollectionFields: (id: NodeId, fields: ManagedCollectionFieldInputData[]) => Promise<void>;
    getManagedCollectionFields: (id: NodeId) => Promise<ManagedCollectionField[]>;
    getManagedCollectionFields2: (id: NodeId) => Promise<ManagedCollectionField[]>;
    addManagedCollectionItems: (id: NodeId, items: ApiV2ManagedCollectionItemInput[]) => Promise<void>;
    addManagedCollectionItems2: (id: NodeId, items: ManagedCollectionItemInput[]) => Promise<void>;
    removeManagedCollectionItems: (id: NodeId, itemIds: string[]) => Promise<void>;
    getCollection: (id: NodeId) => Promise<CollectionData | null>;
    getActiveCollection: () => Promise<CollectionData | null>;
    getCollections: () => Promise<CollectionData[]>;
    getCollectionItems: (id: NodeId) => Promise<ApiV2CollectionItemData[]>;
    getCollectionItems2: (id: NodeId) => Promise<CollectionItemSerializableData[]>;
    setCollectionItemOrder: (collectionId: NodeId, itemIds: NodeId[]) => Promise<void>;
    getCollectionFields: (collectionId: string, includeDividers?: true) => Promise<FieldDefinitionData[]>;
    getCollectionFields2: (collectionId: string, includeDividers?: true) => Promise<FieldDefinitionData[]>;
    addCollectionFields: (collectionId: string, fields: FieldInput[]) => Promise<(FieldDefinitionData | null)[]>;
    addCollectionFields2: (collectionId: string, fields: FieldInput[]) => Promise<(FieldDefinitionData | null)[]>;
    removeCollectionFields: (collectionId: string, fieldIds: string[]) => Promise<void>;
    setCollectionFieldOrder: (collectionId: string, fieldIds: string[]) => Promise<void>;
    addCollectionItems: (id: NodeId, items: ApiV2CollectionItemInput[]) => Promise<ApiV2CollectionItemData[]>;
    addCollectionItems2: (id: NodeId, items: CollectionItemInput[]) => Promise<CollectionItemSerializableData[]>;
    setCollectionItemAttributes: (id: NodeId, attributes: ApiV2EditableCollectionItemAttributes) => Promise<ApiV2CollectionItemData | null>;
    setCollectionItemAttributes2: (id: NodeId, attributes: EditableCollectionItemAttributes) => Promise<CollectionItemSerializableData | null>;
    setActiveCollection: (collectionId: NodeId) => Promise<void>;
    removeCollectionItems: (ids: NodeId[]) => Promise<void>;
    addEnumCase: (collectionId: string, fieldId: string, attributes: CreateEnumCase) => Promise<EnumCaseData | null>;
    updateEnumCase: (collectionId: string, fieldId: string, caseId: string, attributes: UpdateEnumCase) => Promise<EnumCaseData | null>;
    removeEnumCase: (collectionId: string, fieldId: string, caseId: string) => Promise<void>;
    setEnumCaseOrder: (collectionId: string, fieldId: string, caseIds: string[]) => Promise<void>;
    getPluginDataForNode: (id: NodeId, key: string) => Promise<string | null>;
    setPluginDataForNode: (id: NodeId, key: string, value: string | null) => Promise<void>;
    getPluginDataKeysForNode: (id: NodeId) => Promise<string[]>;
    getColorStyle(id: NodeId): Promise<ColorStyleData | null>;
    getColorStyles(): Promise<ColorStyleData[]>;
    createColorStyle(attributes: Record<string, unknown>): Promise<ColorStyleData>;
    setColorStyleAttributes(id: NodeId, update: Record<string, unknown>): Promise<ColorStyleData | null>;
    removeColorStyle(id: NodeId): Promise<void>;
    getTextStyle: (id: NodeId) => Promise<TextStyleData | null>;
    getTextStyles: () => Promise<TextStyleData[]>;
    createTextStyle: (attributes: Record<string, unknown>) => Promise<TextStyleData>;
    setTextStyleAttributes: (id: NodeId, update: Record<string, unknown>) => Promise<TextStyleData | null>;
    removeTextStyle: (id: NodeId) => Promise<void>;
    getFont: (family: string, attributes?: Record<string, unknown>) => Promise<FontData | null>;
    getFonts: () => Promise<FontData[]>;
    /** @deprecated */
    unstable_createCodeFile: (name: string, code: string) => Promise<CodeFileData>;
    /** @deprecated */
    unstable_getCodeFiles: () => Promise<readonly CodeFileData[]>;
    /** @deprecated */
    unstable_getCodeFile: (id: string) => Promise<CodeFileData | null>;
    /** @deprecated */
    unstable_renameCodeFile: (id: string, newName: string) => Promise<CodeFileData>;
    /** @deprecated */
    unstable_removeCodeFile: (id: string) => Promise<void>;
    /** @deprecated */
    unstable_setCodeFileContent: (id: string, code: string) => Promise<CodeFileData>;
    /** @deprecated */
    unstable_getCodeFileVersions: (id: string) => Promise<readonly CodeFileVersionData[]>;
    /** @deprecated */
    unstable_getCodeFileVersionContent: (fileId: string, versionId: string) => Promise<string>;
    /** @deprecated */
    unstable_getCodeFileLint2(fileName: string, content: string, rules: LintConfig): Promise<LintDiagnostic[]>;
    /** @deprecated */
    unstable_getCodeFileTypecheck2(fileName: string, content: string, compilerOptions?: ts.server.protocol.CompilerOptions): Promise<TypecheckDiagnostic[]>;
    createCodeFile: (name: string, code: string) => Promise<CodeFileData>;
    getCodeFiles: () => Promise<readonly CodeFileData[]>;
    getCodeFile: (id: string) => Promise<CodeFileData | null>;
    renameCodeFile: (id: string, newName: string) => Promise<CodeFileData>;
    removeCodeFile: (id: string) => Promise<void>;
    setCodeFileContent: (id: string, code: string) => Promise<CodeFileData>;
    getCodeFileVersions: (id: string) => Promise<readonly CodeFileVersionData[]>;
    getCodeFileVersionContent: (fileId: string, versionId: string) => Promise<string>;
    lintCode(fileName: string, content: string, rules: LintConfig): Promise<LintDiagnostic[]>;
    typecheckCode(fileName: string, content: string, compilerOptions?: ts.server.protocol.CompilerOptions): Promise<TypecheckDiagnostic[]>;
    addRedirects: (redirects: RedirectInput[]) => Promise<RedirectData[]>;
    getRedirects: () => Promise<readonly RedirectData[]>;
    setRedirectOrder: (redirectIds: string[]) => Promise<void>;
    removeRedirects: (redirectIds: string[]) => Promise<void>;
    /** @deprecated Use `getRuntimeErrorForCodeComponentNode` instead. Can be removed when Workshop is updated. */
    getRuntimeErrorForModule: (moduleIdentifier: string) => Promise<string | null>;
    getRuntimeErrorForCodeComponentNode: (nodeId: NodeId) => Promise<NodeRuntimeErrorResult | null>;
    addComponentInstancePlaceholder: (attributes?: ComponentInstancePlaceholderAttributes) => Promise<ComponentInstancePlaceholderData>;
    updateComponentInstancePlaceholder: (id: string, attributes: ComponentInstancePlaceholderAttributes) => Promise<ComponentInstancePlaceholderData | null>;
    removeComponentInstancePlaceholder: (id: string) => Promise<void>;
    replaceComponentInstancePlaceholderWithComponentInstance: (id: string, url: string, attributes?: Partial<EditableComponentInstanceNodeAttributes>) => Promise<SomeNodeData | null>;
    showProgressOnInstances: (codeFileId: string, attributes?: ShowProgressOnInstancesAttributes) => Promise<void>;
    removeProgressFromInstances: (codeFileId: string) => Promise<void>;
    setMenu: (menuItems: MenuItemSerializable[]) => Promise<void>;
    showContextMenu: (menuItems: MenuItemSerializable[], config: ContextMenuConfig) => Promise<void>;
    [getAiServiceInfoMessageType]: () => Promise<AiServiceInfo>;
    [sendTrackingEventMessageType]: (key: string, value: string, identifier: string) => Promise<void>;
    /** @deprecated Use `getAiServiceInfoMessageType`. */
    getAiServiceInfo: () => Promise<AiServiceInfo>;
    /** @deprecated Use `sendTrackingEventMessageType`. */
    sendTrackingEvent: (key: string, value: string, identifier: string) => Promise<void>;
}

declare type PluginMessageId = number;

declare interface PluginMethodInvocation {
    [typeKey]: "methodInvocation";
    methodName: keyof PluginMessageAPI;
    id: PluginMessageId;
    args: unknown[];
}

declare type PluginNodeClass = OtherNodeType | CreateNodeType$1;

declare interface PluginReadyResponse {
    [typeKey]: typeof pluginReadyResponseType;
    mode: Mode;
    theme: Theme;
    permissionMap: PermissionMap;
    environmentInfo: EnvironmentInfo | null;
}

declare const pluginReadyResponseType = "pluginReadyResponse";

declare type PluginReadySignal = typeof readySignal;

declare interface PluginSubscription {
    [typeKey]: "subscribe" | "unsubscribe";
    topic: PluginSubscriptionTopic;
}

declare interface PluginSubscriptionBase {
    [typeKey]: "subscriptionMessage";
    payload: unknown;
}

declare interface PluginSubscriptionCanvasRoot extends PluginSubscriptionBase {
    topic: "canvasRoot";
    payload: SomeNodeData;
}

declare interface PluginSubscriptionCodeFiles extends PluginSubscriptionBase {
    topic: "codeFiles";
    payload: readonly CodeFileData[];
}

declare interface PluginSubscriptionColorStyle extends PluginSubscriptionBase {
    topic: "colorStyles";
    payload: ColorStyleData[];
}

declare interface PluginSubscriptionCustomHTML extends PluginSubscriptionBase {
    topic: "customCode";
    payload: CustomCode;
}

declare type PluginSubscriptionEvent = PluginSubscriptionPublishInfo | PluginSubscriptionSelection | PluginSubscriptionCanvasRoot | PluginSubscriptionImage | PluginSubscriptionTheme | PluginSubscriptionText | PluginSubscriptionCustomHTML | PluginSubscriptionColorStyle | PluginSubscriptionTextStyle | /** @alpha */ PluginSubscriptionRedirects | PluginSubscriptionCodeFiles | /** @alpha */ PluginSubscriptionOpenCodeFile;

declare interface PluginSubscriptionImage extends PluginSubscriptionBase {
    topic: "image";
    payload: ImageAssetData | null;
}

declare interface PluginSubscriptionPublishInfo extends PluginSubscriptionBase {
    topic: "publishInfo";
    payload: PublishInfo;
}

declare interface PluginSubscriptionSelection extends PluginSubscriptionBase {
    topic: "selection";
    payload: SomeNodeData[];
}

declare interface PluginSubscriptionText extends PluginSubscriptionBase {
    topic: "text";
    payload: string | null;
}

declare interface PluginSubscriptionTextStyle extends PluginSubscriptionBase {
    topic: "textStyles";
    payload: TextStyleData[];
}

declare interface PluginSubscriptionTheme extends PluginSubscriptionBase {
    topic: "theme";
    payload: Theme;
}

declare type PluginSubscriptionTopic = PluginSubscriptionEvent["topic"];

declare type PluginToVekterMessage = PluginMethodInvocation | PluginSubscription | PluginReadySignal;

declare interface Point {
    x: number;
    y: number;
}

export declare type Position = "relative" | "absolute" | "fixed" | "sticky";

declare type PostMessage = (message: PluginToVekterMessage, transfer?: Transferable[] | undefined) => void;

/**
 * This alias takes a type as its argument and returns a new type that has the same properties as
 * the original, but the properties are not intersected. This makes the new type easier to read and
 * understand.
 *
 * Example:
 * ```ts
 * // Original type:
 * { a: string; } & { b: number; } & { c: boolean; }
 *
 * // New type:
 * { a: string; b: number; c: boolean; }
 * ```
 */
declare type Prettify<T> = {
    [K in keyof T]: T[K] extends object ? Prettify<T[K]> : T[K];
} & {};

export declare interface ProjectInfo extends ApiVersion1ProjectInfo {
    /** Hashed project id served by API version 1, use for migration only */
    apiVersion1Id: string;
}

declare type ProtectedMessageType = Exclude<keyof PluginMessageAPI, UnprotectedMessageType>;

export declare type ProtectedMethod = keyof {
    [K in Method as (typeof methodToMessageTypes)[K] extends [] ? never : K]: (typeof methodToMessageTypes)[K];
};

export declare interface Publish {
    deploymentTime: number;
    optimizationStatus: OptimizationStatus;
    url: string;
    currentPageUrl: string;
}

export declare interface PublishInfo {
    production: Publish | null;
    staging: Publish | null;
}

export declare class RadialGradient implements RadialGradientOptions {
    readonly width: CSSDimension<CSSUnit.Percentage>;
    readonly height: CSSDimension<CSSUnit.Percentage>;
    readonly x: CSSDimension<CSSUnit.Percentage>;
    readonly y: CSSDimension<CSSUnit.Percentage>;
    readonly stops: readonly ColorStop[];
    constructor(options: RadialGradientOptions);
    cloneWithAttributes(attributes: Partial<RadialGradientOptions>): RadialGradient;
    toCSS(): string;
}

declare const radialGradientClassDiscriminator: "RadialGradient";

declare interface RadialGradientData extends RadialGradientOptions {
    __class: typeof radialGradientClassDiscriminator;
}

declare interface RadialGradientOptions {
    /** Relative width */
    width: CSSDimension<CSSUnit.Percentage>;
    /** Relative height */
    height: CSSDimension<CSSUnit.Percentage>;
    /** Relative horizontal position */
    x: CSSDimension<CSSUnit.Percentage>;
    /** Relative vertical position */
    y: CSSDimension<CSSUnit.Percentage>;
    /** Color stops with position */
    stops: readonly ColorStop[];
}

declare const readySignal: {
    readonly type: "pluginReadySignal";
};

export declare interface Rect {
    x: number;
    y: number;
    width: number;
    height: number;
}

declare type Rect_2 = Point & Size$1;

export declare class Redirect {
    #private;
    /** The id of the redirect. */
    get id(): string;
    /** The source path to redirect from. */
    get from(): string;
    /** The destination path to redirect to. */
    get to(): string | null;
    /** Whether to expand the redirect to all locales. */
    get expandToAllLocales(): boolean;
    constructor(data: RedirectData, engine: PluginEngine);
    /**
     * Remove the redirect.
     */
    remove(): Promise<void>;
    /**
     * Update the redirect attributes.
     *
     * @returns The updated redirect, or `null` if the redirect was not found.
     */
    setAttributes(attributes: Partial<CreateRedirect>): Promise<Redirect | null>;
}

declare interface RedirectAttributes {
    /** The source path to redirect from */
    from: string;
    /** Whether to expand the redirect to all locales */
    expandToAllLocales: boolean;
}

declare interface RedirectData extends RedirectAttributes, WithNullableToField {
    /** The id of the redirect */
    id: string;
}

export declare type RedirectInput = Prettify<CreateRedirect | UpdateRedirect>;

declare type ReleaseChannel = "alpha" | "beta" | "stable";

declare interface RequiredColorStyleAttributes {
    light: string;
}

declare type Resolution = "auto" | "lossless" | "small" | "medium" | "large" | "full";

declare const sendTrackingEventMessageType = "INTERNAL_sendTrackingEvent";

declare const sendTrackingEventSymbol: unique symbol;

export declare interface SeparatorMenuItem {
    type: "separator";
}

declare interface SetCustomCodeOptions {
    html: string | null;
    location: CustomCodeLocation;
}

export declare interface SetLocalizationDataResult {
    /** Set one or more localized values */
    valuesBySource: {
        errors: readonly LocalizationValueError[];
    };
    /** Set the hidden locale IDs of one or more localization groups */
    statusByLocaleByGroup: {
        errors: readonly LocalizationStatusByLocaleError[];
    };
}

declare const showUncheckedPermissionToastsSymbol: unique symbol;

declare interface Size$1 {
    width: number;
    height: number;
}

declare interface Size {
    /** Same as [HTMLImageElement.naturalWidth](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/naturalWidth).
     *
     * **Warning**: May be zero!
     */
    width: number;
    /** Same as [HTMLImageElement.naturalHeight](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/naturalHeight).
     *
     * **Warning**: May be zero!
     */
    height: number;
}

declare type SomeNodeData = FrameNodeData | TextNodeData | ComponentInstanceNodeData | SVGNodeData | WebPageNodeData | ComponentNodeData | VectorSetNodeData | VectorSetItemNodeData | UnknownNodeData;

export declare class StringField extends FieldBaseWithRequired implements WithFieldBasedOn {
    #private;
    readonly type = "string";
    constructor(engine: PluginEngine, collectionId: string, data: StringFieldDefinitionData);
    get basedOn(): string | null;
}

declare interface StringFieldBase {
    type: StringFieldType;
}

declare interface StringFieldDataEntry {
    type: StringFieldType;
    value: string;
    valueByLocale: InlineLocalizationValueByLocale;
}

declare interface StringFieldDataEntryInput {
    type: StringFieldType;
    value: string;
    valueByLocale?: LocalizationSourceUpdate;
}

declare interface StringFieldDefinitionData extends StringFieldBase, WithFieldRequired, WithFieldBasedOn, FieldDefinitionBase {
}

declare type StringFieldType = typeof stringFieldType;

declare const stringFieldType = "string";

/**
 * A collection field that Framer knows about and the plugin API fully supports.
 */
declare type SupportedFieldDefinitionData = BooleanFieldDefinitionData | ColorFieldDefinitionData | NumberFieldDefinitionData | StringFieldDefinitionData | FormattedTextFieldDefinitionData | ImageFieldDefinitionData | LinkFieldDefinitionData | DateFieldDefinitionData | FileFieldDefinitionData | EnumFieldDefinitionData | CollectionReferenceFieldDefinitionData | MultiCollectionReferenceFieldDefinitionData | ArrayFieldDefinitionData;

export declare function supportsAspectRatio<T extends PartialNodeData>(node: T): node is T & WithAspectRatioTrait;

export declare function supportsBackgroundColor<T extends AnyNode>(node: T): node is T & WithBackgroundColorTrait<TraitVariantNode>;

export declare function supportsBackgroundColorData<T extends Partial<AnyNodeData>>(node: T): node is T & WithBackgroundColorTrait<TraitVariantData>;

export declare function supportsBackgroundGradient<T extends PartialNodeData>(node: T): node is T & WithBackgroundGradientTrait<TraitVariantNode>;

export declare function supportsBackgroundGradientData<T extends PartialNodeData>(node: T): node is T & WithBackgroundGradientTrait<TraitVariantData>;

export declare function supportsBackgroundImage<T extends AnyNode>(node: T): node is T & WithBackgroundImageTrait<TraitVariantNode>;

export declare function supportsBackgroundImageData<T extends Partial<AnyNodeData>>(node: T): node is T & WithBackgroundImageTrait<TraitVariantData>;

export declare function supportsBorderRadius<T extends PartialNodeData>(node: T): node is T & WithBorderRadiusTrait;

export declare function supportsComponentInfo<T extends PartialNodeData>(node: T): node is T & WithComponentInfoTrait;

export declare function supportsFont<T extends PartialNodeData>(node: T): node is T & WithFontTrait<TraitVariantNode>;

export declare function supportsFontData<T extends PartialNodeData>(node: T): node is T & WithFontTrait<TraitVariantData>;

export declare function supportsImageRendering<T extends PartialNodeData>(node: T): node is T & WithImageRenderingTrait;

export declare function supportsInlineTextStyle<T extends PartialNodeData>(node: T): node is T & WithInlineTextStyleTrait<TraitVariantNode>;

export declare function supportsInlineTextStyleData<T extends PartialNodeData>(node: T): node is T & WithInlineTextStyleTrait<TraitVariantData>;

export declare function supportsLink<T extends PartialNodeData>(node: T): node is T & WithLinkTrait;

export declare function supportsLocked<T extends PartialNodeData>(node: T): node is T & WithLockedTrait;

export declare function supportsName<T extends PartialNodeData>(node: T): node is T & WithNameTrait;

export declare function supportsOpacity<T extends PartialNodeData>(node: T): node is T & WithOpacityTrait;

export declare function supportsPins<T extends PartialNodeData>(node: T): node is T & WithPinsTrait;

export declare function supportsPosition<T extends PartialNodeData>(node: T): node is T & WithPositionTrait;

export declare function supportsRotation<T extends PartialNodeData>(node: T): node is T & WithRotationTrait;

export declare function supportsSize<T extends PartialNodeData>(node: T): node is T & WithSizeTrait;

export declare function supportsSizeConstraints<T extends PartialNodeData>(node: T): node is T & WithSizeConstraintsTrait;

export declare function supportsSVG<T extends PartialNodeData>(node: T): node is T & WithSVGTrait;

export declare function supportsVisible<T extends PartialNodeData>(node: T): node is T & WithVisibleTrait;

declare interface SVGData extends WithOptionalName {
    svg: string;
}

declare interface SvgDragData extends WithOptionalName$1, WithOptionalPreviewImage {
    type: "svg";
    svg: string;
    /** Inverts SVG drag preview in dark mode. Defaults to true. */
    invertInDarkMode?: boolean;
}

export declare class SVGNode extends NodeMethods implements EditableSVGNodeAttributes {
    readonly __class: SVGNodeData["__class"];
    readonly name: string | null;
    readonly visible: boolean;
    readonly locked: boolean;
    readonly svg: string;
    readonly rotation: number;
    readonly opacity: number;
    readonly position: Position;
    readonly top: CSSDimension<CSSUnit.Pixel> | null;
    readonly right: CSSDimension<CSSUnit.Pixel> | null;
    readonly bottom: CSSDimension<CSSUnit.Pixel> | null;
    readonly left: CSSDimension<CSSUnit.Pixel> | null;
    readonly centerX: CSSDimension<CSSUnit.Percentage> | null;
    readonly centerY: CSSDimension<CSSUnit.Percentage> | null;
    readonly width: WidthLength | null;
    readonly height: HeightLength | null;
    constructor(rawData: SVGNodeData, engine: PluginEngine);
}

declare interface SVGNodeData extends CommonNodeData, Partial<DrawableNode>, WithPositionTrait, Partial<WithPinsTrait>, Partial<WithSizeTrait>, WithSVGTrait, Partial<WithRotationTrait> {
    __class: "SVGNode";
}

export declare type TextAlignment = "left" | "center" | "right" | "justify";

export declare type TextDecoration = "none" | "underline" | "line-through";

declare type TextDecorationSkipInk = "none" | "all" | "auto";

declare type TextDecorationStyle = "solid" | "double" | "dotted" | "dashed" | "wavy";

export declare class TextNode extends NodeMethods implements EditableTextNodeAttributes {
    #private;
    readonly __class: TextNodeData["__class"];
    readonly name: string | null;
    readonly visible: boolean;
    readonly locked: boolean;
    readonly rotation: number;
    readonly opacity: number;
    readonly font: Font | null;
    readonly inlineTextStyle: TextStyle | null;
    readonly position: Position;
    readonly top: CSSDimension<CSSUnit.Pixel> | null;
    readonly right: CSSDimension<CSSUnit.Pixel> | null;
    readonly bottom: CSSDimension<CSSUnit.Pixel> | null;
    readonly left: CSSDimension<CSSUnit.Pixel> | null;
    readonly centerX: CSSDimension<CSSUnit.Percentage> | null;
    readonly centerY: CSSDimension<CSSUnit.Percentage> | null;
    readonly width: WidthLength | null;
    readonly height: HeightLength | null;
    readonly maxWidth: WidthConstraint | null;
    readonly minWidth: WidthConstraint | null;
    readonly maxHeight: HeightConstraint | null;
    readonly minHeight: HeightConstraint | null;
    readonly link: string | null;
    readonly linkOpenInNewTab: boolean | null;
    constructor(rawData: TextNodeData, engine: PluginEngine);
    /**
     * Set the text of this node. Plain text content, not HTML.
     *
     * Use `"TextNode.setText"` to check if this method is allowed.
     */
    setText(text: string): Promise<void>;
    /**
     * Get the text of this node. Plain text content, not HTML.
     */
    getText(): Promise<string | null>;
}

declare interface TextNodeData extends CommonNodeData, Partial<DrawableNode>, WithPositionTrait, Partial<WithPinsTrait>, Partial<WithSizeTrait>, Partial<WithSizeConstraintsTrait>, Partial<WithRotationTrait>, Partial<WithLinkTrait>, Partial<WithFontTrait<TraitVariantData>>, Partial<WithInlineTextStyleTrait<TraitVariantData>> {
    __class: "TextNode";
}

declare type TextNodeTag = "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "p";

export declare class TextStyle {
    #private;
    readonly id: NodeId;
    readonly name: string;
    /**
     * Hierarchical path to the text style in the assets folder structure, e.g. `ui/modals/text`.
     * Used for organizing text styles in the UI and for programmatic access.
     * Segments are separated by forward slashes.
     */
    readonly path: string;
    /** HTML tag that the style will use. */
    readonly tag: TextStyleTag;
    /**
     * Base font of the text.
     *
     * Setting this will automatically update `boldFont`, `italicFont` or
     * `boldItalicFont` with the appropriate variants if they are not already
     * specified.
     * */
    readonly font: Font;
    /**
     * Font to use for bold text.
     *
     * Note: This must have the same family name as the base `font` attribute.
     * */
    readonly boldFont: Font | null;
    /**
     * Font to use for italic text.
     *
     * Note: This must be the same family name as the base `font` attribute.
     * */
    readonly italicFont: Font | null;
    /**
     * Font to use for bold italic text.
     *
     * Note: This must have the same family name as the base `font` attribute.
     * */
    readonly boldItalicFont: Font | null;
    /** Color of the text in RGBA format for all breakpoints, e.g `rgba(242, 59, 57, 1)` */
    readonly color: ColorStyle | string;
    /** Specifies how to capitalize the text for all breakpoints. */
    readonly transform: TextTransform;
    /** Specifies the horizontal direction of the text for all breakpoints. */
    readonly alignment: TextAlignment;
    /** Appearance of any decorative lines on the text for all breakpoints. */
    readonly decoration: TextDecoration;
    /** Color of the text decoration in RGBA format for all breakpoints, e.g `rgba(242, 59, 57, 1)` */
    readonly decorationColor: ColorStyle | string;
    /** Thickness of the text decoration for all breakpoints. */
    readonly decorationThickness: "auto" | CSSDimension<CSSUnit.Pixel | CSSUnit.Em>;
    /** Style of the text decoration for all breakpoints. */
    readonly decorationStyle: TextDecorationStyle;
    /** Whether to skip ink when drawing the text decoration for all breakpoints. */
    readonly decorationSkipInk: TextDecorationSkipInk;
    /** Offset of the text decoration for all breakpoints. */
    readonly decorationOffset: "auto" | CSSDimension<CSSUnit.Pixel | CSSUnit.Em>;
    /** When enabled, use a text wrap method that tries to balance the number of characters on each line for legibility. */
    readonly balance: boolean;
    /** A list of style overrides that take affect at specific window widths. Breakpoints are automatically sorted by `minWidth` from largest to smallest. */
    readonly breakpoints: TextStyleBreakpoint[];
    /**
     * How big does the window width need to be for primary breakpoint styles to
     * take affect.
     *
     * Note: This is ignored if the text style has no breakpoints.
     * */
    readonly minWidth: number;
    /**
     * Size of the text of the primary breakpoint.
     *
     * Note: This is used by default when there are no breakpoints.
     * */
    readonly fontSize: CSSDimension<CSSUnit.Pixel | CSSUnit.Rem>;
    /**
     * Size of the space between each letter for the primary breakpoint.
     *
     * Note: This is used by default when there are no breakpoints.
     * */
    readonly letterSpacing: CSSDimension<CSSUnit.Pixel | CSSUnit.Em>;
    /**
     * Size of the space between each line of text for the primary breakpoint.
     *
     * Note: This is used by default when there are no breakpoints.
     * */
    readonly lineHeight: CSSDimension<CSSUnit.Pixel | CSSUnit.Em | CSSUnit.Percentage>;
    /**
     * Size of the space between each paragraph for the primary breakpoint.
     *
     * Note: This is used by default when there are no breakpoints.
     * */
    readonly paragraphSpacing: number;
    constructor(data: TextStyleData, engine: PluginEngine);
    /**
     * Set the attributes of the text style.
     *
     * @throws If the number of breakpoints is bigger than the limit of 4.
     * @throws If any of the font families used for `boldFont`, `italicFont` and
     * `boldItalicFont` do not match the family of `font`.
     *
     * Use `"TextStyle.setAttributes"` to check if this method is allowed.
     */
    setAttributes(attributes: TextStyleAttributes): Promise<TextStyle | null>;
    /**
     * Get plugin data for this text style by key.
     */
    getPluginData(key: string): Promise<string | null>;
    /**
     * Set plugin data on this text style by key.
     *
     * Use `"TextStyle.setPluginData"` to check if this method is allowed.
     */
    setPluginData(key: string, value: string | null): Promise<void>;
    /**
     * Get all plugin data keys for this text style.
     */
    getPluginDataKeys(): Promise<string[]>;
    /**
     * Deletes the text style from the project.
     *
     * Use `"TextStyle.remove"` to check if this method is allowed.
     */
    remove(): Promise<void>;
}

declare type TextStyleAttributes = Prettify<Partial<Omit<TextStyleData, "id" | "color" | "font" | "boldFont" | "italicFont" | "boldItalicFont" | "breakpoints"> & {
    color: ColorStyle | string;
    font: Font;
    boldFont: Font | null;
    italicFont: Font | null;
    boldItalicFont: Font | null;
    breakpoints: TextStyleBreakpointAttributes[];
}> & AssetPath>;

export declare type TextStyleBreakpoint = Prettify<TextStyleBreakpointData>;

declare type TextStyleBreakpointAttributes = Prettify<Partial<TextStyleBreakpointData> & Pick<TextStyleBreakpointData, "minWidth">>;

declare interface TextStyleBreakpointData {
    /**
     * How big does the window width need to be for this breakpoint's styles to
     * take affect.
     *
     * This must be unique for each breakpoint.
     * */
    minWidth: number;
    /** Size of the text at this breakpoint. */
    fontSize: CSSDimension<CSSUnit.Pixel | CSSUnit.Rem>;
    /** Size of the space between each letter at this breakpoint. */
    letterSpacing: CSSDimension<CSSUnit.Pixel | CSSUnit.Em>;
    /** Size of the space between each line of text at this breakpoint. */
    lineHeight: CSSDimension<CSSUnit.Pixel | CSSUnit.Em | CSSUnit.Percentage>;
    /** Size of the space between each paragraph at this breakpoint. */
    paragraphSpacing: number;
}

declare interface TextStyleData extends TextStyleBreakpointData {
    __class: typeof textStyleDiscriminator;
    id: NodeId;
    name: string;
    path: string;
    tag: TextStyleTag;
    color: ColorStyleData | string;
    font: FontData;
    boldFont: FontData | null;
    italicFont: FontData | null;
    boldItalicFont: FontData | null;
    transform: TextTransform;
    alignment: TextAlignment;
    decoration: TextDecoration;
    decorationColor: ColorStyleData | string;
    decorationThickness: "auto" | CSSDimension<CSSUnit.Pixel | CSSUnit.Em>;
    decorationStyle: TextDecorationStyle;
    decorationSkipInk: TextDecorationSkipInk;
    decorationOffset: "auto" | CSSDimension<CSSUnit.Pixel | CSSUnit.Em>;
    balance: boolean;
    breakpoints: TextStyleBreakpointData[];
}

declare const textStyleDiscriminator: "TextStyle";

export declare type TextStyleTag = "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "p";

export declare type TextTransform = "none" | "inherit" | "capitalize" | "uppercase" | "lowercase";

declare interface Theme {
    mode: ThemeMode;
    tokens: ThemeTokens;
}

declare type ThemeMode = "light" | "dark";

declare interface ThemeTokens {
    "--framer-color-tint": string;
    "--framer-color-tint-dimmed": string;
    "--framer-color-tint-dark": string;
    "--framer-color-text": string;
    "--framer-color-text-secondary": string;
    "--framer-color-text-tertiary": string;
    "--framer-color-text-reversed": string;
    "--framer-color-bg": string;
    "--framer-color-bg-secondary": string;
    "--framer-color-bg-tertiary": string;
    "--framer-color-divider": string;
    "--framer-color-tint-extra-dark": string;
}

export declare type TraitVariant = TraitVariantData | TraitVariantNode;

export declare type TraitVariantData = "data";

export declare type TraitVariantNode = "node";

export declare interface TypecheckDiagnostic extends DiagnosticBase {
    /**
     * The span of the invalid code in the file.
     * Could be undefined if the diagnostic is system-level (and not file-specific), like e.g. an error about invalid TS options.
     */
    span?: DiagnosticSpan;
    /** Could be undefined if the diagnostic is system-level (and not file-specific), like e.g. an error about invalid TS options */
    fileName?: string;
    code: number;
    category: ts.DiagnosticCategory;
}

declare const typeKey = "type";

export declare interface UIOptions {
    /** The preferred UI width. */
    width?: number;
    /** The preferred UI height. */
    height?: number;
    /** The initial window position, defaults to top left. */
    position?: "center" | "top left" | "bottom left" | "top right" | "bottom right";
    /** Whether the UI is resizable. */
    resizable?: true | false | "width" | "height";
    /** Minimum UI width. */
    minWidth?: number;
    /** Minimum UI height. */
    minHeight?: number;
    /** Maximum UI width. */
    maxWidth?: number;
    /** Maximum UI height. */
    maxHeight?: number;
}

declare class UnknownNode extends NodeMethods {
    readonly __class: UnknownNodeData["__class"];
    constructor(rawData: UnknownNodeData, engine: PluginEngine);
}

declare interface UnknownNodeData extends CommonNodeData {
    __class: "UnknownNode";
}

declare type UnprotectedMessageType = (typeof unprotectedMessageTypesSource)[number];

declare const unprotectedMessageTypesSource: ["closeNotification", "closePlugin", "getActiveCollection", "getActiveLocale", "getActiveManagedCollection", "getCanvasRoot", "getChildren", "getCollection", "getCollectionFields", "getCollectionFields2", "getCollectionItems", "getCollectionItems2", "getCollections", "getColorStyle", "getColorStyles", "getCurrentUser", "getCurrentUser2", "getCustomCode", "getDefaultLocale", "getFont", "getFonts", "getImage", "getImageData", "getLocales", "getLocalizationGroups", "getManagedCollection", "getManagedCollectionFields", "getManagedCollectionFields2", "getManagedCollectionItemIds", "getManagedCollections", "getNode", "getNodesWithAttribute", "getNodesWithAttributeSet", "getNodesWithType", "getParent", "getPluginData", "getPluginDataForNode", "getPluginDataKeys", "getPluginDataKeysForNode", "getProjectInfo", "getProjectInfo2", "getPublishInfo", "getRect", "getSelection", "getSVGForNode", "getText", "getTextForNode", "getTextStyle", "getTextStyles", "hideUI", "notify", "onPointerDown", "setActiveCollection", "setSelection", "showUI", "getCodeFileVersionContent", "lintCode", "typecheckCode", "getCodeFileVersions", "getCodeFiles", "getCodeFile", "getRedirects", "uploadFile", "uploadFiles", "uploadImage", "uploadImages", "zoomIntoView", "getRuntimeErrorForModule", "getRuntimeErrorForCodeComponentNode", "showProgressOnInstances", "removeProgressFromInstances", "addComponentInstancePlaceholder", "updateComponentInstancePlaceholder", "removeComponentInstancePlaceholder", "setMenu", "showContextMenu", "INTERNAL_getAiServiceInfo", "INTERNAL_sendTrackingEvent", "getAiServiceInfo", "sendTrackingEvent", "unstable_getCodeFile", "unstable_getCodeFiles", "unstable_getCodeFileVersionContent", "unstable_getCodeFileLint2", "unstable_getCodeFileTypecheck2", "unstable_getCodeFileVersions"];

declare type Unsubscribe$1 = VoidFunction;

declare type Unsubscribe = VoidFunction;

export declare class UnsupportedField extends FieldBase {
    readonly type = "unsupported";
}

declare interface UnsupportedFieldBase {
    type: UnsupportedFieldType;
}

declare interface UnsupportedFieldDefinitionData extends UnsupportedFieldBase, FieldDefinitionBase {
}

declare type UnsupportedFieldType = typeof unsupportedFieldType;

declare const unsupportedFieldType = "unsupported";

declare interface UpdateArrayField extends ArrayFieldBase, UpdateFieldBase, WithOptionalFieldRequired {
    fields?: [CreateArrayItemField];
}

declare interface UpdateArrayItem extends EditableArrayItemAttributes {
    /** The ID of an existing item if updating. Omit if adding. */
    id: string;
}

declare interface UpdateBooleanField extends BooleanFieldBase, UpdateFieldBase {
}

declare interface UpdateCollectionReferenceField extends CollectionReferenceFieldBase, UpdateFieldBase, WithOptionalFieldRequired {
}

declare interface UpdateColorField extends ColorFieldBase, UpdateFieldBase {
}

declare interface UpdateDateField extends DateFieldBase, UpdateFieldBase, WithOptionalFieldRequired {
}

declare type UpdateEnumCase = Partial<WithEnumCaseNameInput>;

declare interface UpdateEnumField extends EnumFieldBase, UpdateFieldBase {
}

declare type UpdateField = UpdateBooleanField | UpdateColorField | UpdateNumberField | UpdateStringField | UpdateFormattedTextField | UpdateImageField | UpdateLinkField | UpdateDateField | UpdateFileField | UpdateEnumField | UpdateCollectionReferenceField | UpdateMultiCollectionReferenceField | UpdateFieldDivider | UpdateUnsupportedField | UpdateArrayField;

/**
 * The type of the `attributes` parameter of `Field.setAttributes`:
 *
 * ```ts
 * const fileFieldAttributes: UpdateFieldAttributes<FileField> = {}
 * fileFieldAttributes.allowedFileTypes = []
 * fileField.setAttributes(fileFieldAttributes)
 * ```
 *
 * Can also use `typeof`:
 *
 * ```ts
 * const fileFieldAttributes: UpdateFieldAttributes<typeof fileField> = {}
 * ```
 */
export declare type UpdateFieldAttributes<T extends {
    type: UpdateField["type"];
}> = Omit<Extract<UpdateField, {
    type: T["type"];
}>, // This is NOT the same as Extract<UpdateField, T>
// This is NOT the same as Extract<UpdateField, T>
"id" | "type">;

declare interface UpdateFieldBase extends WithFieldId, Partial<WithFieldName> {
}

declare interface UpdateFieldDivider extends FieldDividerBase, UpdateFieldBase {
}

declare interface UpdateFileField extends FileFieldBase, UpdateFieldBase, Partial<WithFieldAllowedFileTypes>, WithOptionalFieldRequired {
}

declare interface UpdateFormattedTextField extends FormattedTextFieldBase, UpdateFieldBase, WithOptionalFieldRequired {
}

declare interface UpdateImageField extends ImageFieldBase, UpdateFieldBase, WithOptionalFieldRequired {
}

declare interface UpdateLinkField extends LinkFieldBase, UpdateFieldBase, WithOptionalFieldRequired {
}

declare interface UpdateMultiCollectionReferenceField extends MultiCollectionReferenceFieldBase, UpdateFieldBase, WithOptionalFieldRequired {
}

declare interface UpdateNumberField extends NumberFieldBase, UpdateFieldBase {
}

declare interface UpdateRedirect extends Partial<RedirectAttributes>, Partial<WithToField> {
    /** The id of the redirect, if provided, the redirect will be updated, otherwise a new redirect will be created */
    id: string;
}

declare interface UpdateStringField extends StringFieldBase, UpdateFieldBase, WithOptionalFieldRequired {
}

declare interface UpdateUnsupportedField extends UnsupportedFieldBase, UpdateFieldBase {
}

/**
 * Find out if user's permissions allow them to execute all of `methods`:
 *
 * ```tsx
 * const isAllowedToRemoveItem = useIsAllowedTo("CollectionItem.remove")
 * <button disabled={!isAllowedToRemoveItem}>Remove Item</button>
 * ```
 *
 * This is a thin wrapper around `framer.subscribeToIsAllowedTo`.
 */
export declare function useIsAllowedTo(...methods: [ProtectedMethod, ...ProtectedMethod[]]): boolean;

export declare function useMakeDraggable(ref: RefObject<HTMLElement>, data: DragData | (() => DragData), onDragComplete?: DragCompleteCallback): void;

export declare interface User extends ApiVersion1User {
    /** Hashed user id served by API version 1, use for migration only */
    apiVersion1Id: string;
    avatarUrl?: string | undefined;
    /** For when there is no avatar. */
    initials: string;
}

export declare class VectorSetItemNode extends NodeMethods implements EditableVectorSetItemNodeAttributes {
    #private;
    readonly __class: VectorSetItemNodeData["__class"];
    readonly name: string | null;
    readonly visible: boolean;
    readonly locked: boolean;
    readonly top: CSSDimension<CSSUnit.Pixel> | null;
    readonly right: CSSDimension<CSSUnit.Pixel> | null;
    readonly bottom: CSSDimension<CSSUnit.Pixel> | null;
    readonly left: CSSDimension<CSSUnit.Pixel> | null;
    readonly centerX: CSSDimension<CSSUnit.Percentage> | null;
    readonly centerY: CSSDimension<CSSUnit.Percentage> | null;
    readonly width: WidthLength | null;
    readonly height: HeightLength | null;
    constructor(rawData: VectorSetItemNodeData, engine: PluginEngine);
    getSVG(): Promise<string | null>;
}

declare interface VectorSetItemNodeData extends CommonNodeData, Partial<WithNameTrait>, Partial<WithVisibleTrait>, Partial<WithLockedTrait>, Partial<WithPinsTrait>, Partial<WithSizeTrait> {
    __class: "VectorSetItemNode";
}

export declare class VectorSetNode extends NodeMethods implements EditableVectorSetNodeAttributes {
    readonly __class: VectorSetNodeData["__class"];
    readonly name: string | null;
    constructor(rawData: VectorSetNodeData, engine: PluginEngine);
}

declare interface VectorSetNodeData extends CommonNodeData, Partial<WithNameTrait> {
    __class: "VectorSetNode";
}

export declare class WebPageNode extends NodeMethods implements EditableWebPageNodeAttributes, WithWebPageInfoTrait {
    readonly __class: WebPageNodeData["__class"];
    /**
     * The relative path to the WebPage
     */
    readonly path: string | null;
    /**
     * The Collection ID of the CMS Collection if the WebPage is a CMS Detail Page
     */
    readonly collectionId: string | null;
    constructor(rawData: WebPageNodeData, engine: PluginEngine);
}

declare interface WebPageNodeData extends CommonNodeData, Partial<WithWebPageInfoTrait> {
    __class: "WebPageNode";
}

export declare type WidthConstraint = CSSDimension<CSSUnit.Pixel | CSSUnit.Percentage>;

export declare type WidthLength = Length | FitContent;

export declare interface WithAspectRatioTrait {
    aspectRatio: number | null;
}

declare interface WithAssetName {
    name?: string;
    path?: never;
}

declare interface WithAssetPath {
    name?: never;
    path?: string;
}

export declare interface WithBackgroundColorTrait<T extends TraitVariant> {
    /** Color of the frame in RGBA format, e.g `rgba(242, 59, 57, 1)`, or as a `ColorStyle` instance. */
    readonly backgroundColor: (T extends TraitVariantData ? ColorStyleData : ColorStyle) | string | null;
}

export declare interface WithBackgroundGradientTrait<T extends TraitVariant> {
    readonly backgroundGradient: (T extends TraitVariantData ? GradientData : Gradient) | null;
}

export declare interface WithBackgroundImageTrait<T extends TraitVariant> {
    readonly backgroundImage: (T extends TraitVariantData ? ImageAssetData : ImageAsset) | null;
}

export declare interface WithBorderRadiusTrait {
    readonly borderRadius: BorderRadius;
}

export declare interface WithComponentInfoTrait extends WithRequiredComponentInfoTrait, WithNullableComponentInfoTrait {
}

export declare interface WithControlAttributesTrait {
    readonly controls: ControlAttributes;
}

declare interface WithEnumCaseId {
    id: string;
}

declare interface WithEnumCaseName {
    name: string;
    nameByLocale: InlineLocalizationValueByLocale;
}

declare interface WithEnumCaseNameInput {
    name: string;
    nameByLocale?: LocalizationSourceUpdate;
}

declare interface WithEnumCaseNameInputForUpdate {
    name: string;
    nameByLocale?: Record<LocaleId, LocalizedValueUpdate | LocalizationValue>;
}

declare interface WithFieldAllowedFileTypes {
    allowedFileTypes: string[];
}

declare interface WithFieldBasedOn {
    /**
     * The ID of the field on which this field is based.
     *
     * When set, this field will use the referenced field's value as a fallback
     * when no value is provided.
     */
    basedOn: string | null;
}

declare interface WithFieldCollectionId {
    collectionId: string;
}

declare interface WithFieldId {
    /** Required unique ID. Use a unique identifier to prevent data loss when the field is renamed. */
    id: string;
}

declare interface WithFieldName {
    /** The name of the field as displayed in the UI. */
    name: string;
}

declare interface WithFieldRequired {
    required: boolean;
}

export declare interface WithFontTrait<T extends TraitVariant> {
    readonly font: (T extends TraitVariantData ? FontData : Font) | null;
}

declare interface WithIdAndOptionalUserEditable extends WithFieldId, Partial<WithUserEditable> {
}

export declare interface WithIdTrait {
    readonly id: NodeId;
}

export declare interface WithImageRenderingTrait {
    readonly imageRendering: ImageRendering | null;
}

export declare interface WithInlineTextStyleTrait<T extends TraitVariant> {
    readonly inlineTextStyle: (T extends TraitVariantData ? TextStyleData : TextStyle) | null;
}

export declare interface WithLinkTrait {
    readonly link: string | null;
    readonly linkOpenInNewTab: boolean | null;
}

export declare interface WithLockedTrait {
    readonly locked: boolean;
}

export declare interface WithNameTrait {
    readonly name: string | null;
}

export declare interface WithNullableComponentInfoTrait {
    readonly insertURL: string | null;
    readonly componentName: string | null;
}

declare interface WithNullableToField {
    /** The destination path to redirect to. If the page was removed and the redirect is no longer valid, the value
     * will be set to null */
    to: string | null;
}

export declare interface WithOpacityTrait {
    readonly opacity: number;
}

declare type WithOptionalFieldRequired = Partial<WithFieldRequired>;

declare interface WithOptionalName$1 {
    name?: string;
}

declare interface WithOptionalName {
    name?: string;
}

declare interface WithOptionalPreviewImage {
    previewImage?: string;
}

export declare interface WithPinsTrait {
    top: CSSDimension<CSSUnit.Pixel> | null;
    right: CSSDimension<CSSUnit.Pixel> | null;
    bottom: CSSDimension<CSSUnit.Pixel> | null;
    left: CSSDimension<CSSUnit.Pixel> | null;
    centerX: CSSDimension<CSSUnit.Percentage> | null;
    centerY: CSSDimension<CSSUnit.Percentage> | null;
}

export declare interface WithPositionTrait {
    position: Position;
}

export declare interface WithReplicaInfoTrait {
    readonly originalId: string | null;
}

export declare interface WithRequiredComponentInfoTrait {
    readonly componentIdentifier: string;
}

export declare interface WithRotationTrait {
    readonly rotation: number;
}

export declare interface WithSizeConstraintsTrait {
    maxWidth: WidthConstraint | null;
    minWidth: WidthConstraint | null;
    maxHeight: HeightConstraint | null;
    minHeight: HeightConstraint | null;
}

export declare interface WithSizeTrait {
    width: WidthLength | null;
    height: HeightLength | null;
}

export declare interface WithSVGTrait {
    readonly svg: string;
}

declare interface WithToField {
    /** The destination path to redirect to */
    to: string;
}

declare interface WithUserEditable {
    /** Is the user able to edit the field within the UI. */
    userEditable: boolean;
}

export declare interface WithVisibleTrait {
    readonly visible: boolean;
}

export declare interface WithWebPageInfoTrait {
    readonly path: string | null;
    readonly collectionId: string | null;
}

declare interface ZoomIntoViewOptions {
    /**
     * Set a percentage limit for the maximum zoom level.
     *
     * For example, use a value of `1.0` to ensure the zoom does not exceed 100%.
     */
    maxZoom?: number;
}

export { }
